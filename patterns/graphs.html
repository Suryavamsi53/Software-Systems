<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graph Algorithms - Software Systems Prep</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>üåë Software Systems</h1>
        <p>Coding Interview Prep</p>
      </div>
      <nav class="sidebar-nav">
        <a href="../index.html" class="nav-item">üè† Home Dashboard</a>
    
        <!-- Linear Data Structures -->
        <details class="nav-section">
          <summary class="nav-section-title">Linear Data Structures</summary>
          <a href="linked-lists.html" class="nav-item">Linked Lists</a>
          <a href="linked-list-reversal.html" class="nav-item indent">‚Ü≥ Visualizer: Reversal</a>
          <a href="linked-list-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Operations</a>
          <a href="stack.html" class="nav-item">Stacks</a>
          <a href="stack-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Stack</a>
          <a href="queues.html" class="nav-item">Queues</a>
          <a href="queue-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Queue</a>
        </details>
    
        <!-- Non-Linear Data Structures -->
        <details class="nav-section" open>
          <summary class="nav-section-title">Non-Linear Data Structures</summary>
          <a href="hash-maps.html" class="nav-item">Hash Maps</a>
          <a href="hash-map-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Hash Map</a>
          <a href="trees.html" class="nav-item">Trees</a>
          <a href="bst-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: BST</a>
          <a href="graphs.html" class="nav-item active">Graphs</a>
          <a href="graph-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Graph Algo</a>
          <a href="bfs-graph.html" class="nav-item indent">‚Ü≥ Visualizer: BFS</a>
          <a href="pathfinding-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Pathfinding</a>
          <a href="topological-sort-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Topo Sort</a>
          <a href="mst-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: MST</a>
          <a href="union-find.html" class="nav-item indent">‚Ü≥ Visualizer: Union-Find</a>
          <a href="heap.html" class="nav-item">Heaps</a>
          <a href="heap-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Heap</a>
          <a href="tries.html" class="nav-item">Tries</a>
          <a href="trie-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Trie</a>
          <a href="segment-tree.html" class="nav-item">Segment Trees</a>
        </details>
    
        <!-- Algorithms -->
        <details class="nav-section">
          <summary class="nav-section-title">Algorithms</summary>
          <a href="sort-search.html" class="nav-item">Sorting & Search</a>
          <a href="sorting-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Sorting</a>
          <a href="binary-search-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Binary Search</a>
          <a href="dynamic-programming.html" class="nav-item">Dynamic Programming</a>
          <a href="knapsack-dp.html" class="nav-item indent">‚Ü≥ Visualizer: Knapsack</a>
          <a href="dp-lcs.html" class="nav-item indent">‚Ü≥ Visualizer: LCS</a>
          <a href="backtracking.html" class="nav-item">Backtracking</a>
          <a href="n-queens.html" class="nav-item indent">‚Ü≥ Visualizer: N-Queens</a>
          <a href="sudoku-solver.html" class="nav-item indent">‚Ü≥ Visualizer: Sudoku</a>
          <a href="maze-generator.html" class="nav-item indent">‚Ü≥ Visualizer: Maze</a>
          <a href="greedy.html" class="nav-item">Greedy</a>
          <a href="bit-manipulation.html" class="nav-item">Bit Manipulation</a>
          <a href="math-geometry.html" class="nav-item">Math & Geometry</a>
        </details>

        <!-- Patterns -->
        <details class="nav-section">
          <summary class="nav-section-title">Patterns</summary>
          <a href="two-pointers.html" class="nav-item">Two Pointers</a>
          <a href="two-pointers-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Two Pointers</a>
          <a href="sliding-window.html" class="nav-item">Sliding Window</a>
          <a href="sliding-window-visualizer.html" class="nav-item indent">‚Ü≥ Visualizer: Sliding Window</a>
          <a href="fast-slow-pointers.html" class="nav-item">Fast & Slow Pointers</a>
          <a href="binary-search.html" class="nav-item">Binary Search</a>
          <a href="intervals.html" class="nav-item">Intervals</a>
          <a href="prefix-sum.html" class="nav-item">Prefix Sum</a>
        </details>
    
        <!-- System Design -->
        <details class="nav-section">
          <summary class="nav-section-title">System Design</summary>
          <a href="../system-design.html" class="nav-item">System Design Basics</a>
          <a href="../system-design-masterclass.html" class="nav-item">Masterclass (Part 1)</a>
          <a href="../system-design-patterns.html" class="nav-item">System Design Patterns</a>
          <a href="../system-design-checklist.html" class="nav-item">System Design Checklist</a>
          <a href="../system-design-case-studies.html" class="nav-item">Case Studies</a>
          <a href="../system-design-quiz.html" class="nav-item">System Design Quiz</a>
        </details>

        <!-- Guides & Tools -->
        <details class="nav-section">
          <summary class="nav-section-title">Guides & Tools</summary>
          <a href="../pattern-recognition-guide.html" class="nav-item">Pattern Recognition</a>
          <a href="../interview-approach.html" class="nav-item">Interview Approach</a>
          <a href="../complexity-guide.html" class="nav-item">Complexity Analysis</a>
          <a href="../dsa-roadmap.html" class="nav-item">DSA Roadmap</a>
          <a href="../mock-interview-checklist.html" class="nav-item">Mock Interview Checklist</a>
          <a href="../cs-fundamentals.html" class="nav-item">CS Fundamentals</a>
          <a href="../golang-guide.html" class="nav-item">Go Language Guide</a>
          <a href="../osi-layers.html" class="nav-item">OSI Model Deep Dive</a>
          <a href="../tcp-ip-model.html" class="nav-item">TCP/IP Model Deep Dive</a>
          <a href="../go-interview-questions.html" class="nav-item">Go Interview Questions</a>
          <a href="../google-interview-questions.html" class="nav-item">Google Interview Questions</a>
          <a href="../amazon-two-pointers-questions.html" class="nav-item">Amazon Two Pointers Questions</a>
          <a href="../go-interview-plan.html" class="nav-item">üìÖ 14-Day Interview Plan</a>
          <a href="../google-roadmap.html" class="nav-item">üó∫Ô∏è Google Roadmap</a>
          <a href="../cheat-sheet.html" class="nav-item">Pattern Cheat Sheet</a>
          <a href="../dashboard.html" class="nav-item">üìä My Dashboard</a>
          <a href="../mobile-access.html" class="nav-item">üì± Mobile Access</a>
        </details>
      </nav>
    </aside>

    <main class="main-content">
      <div class="content-header">
        <h1>üï∏Ô∏è Graph Algorithms Masterclass</h1>
        <p>The backbone of Google Maps, Social Networks, and the Internet.</p>
      </div>

      <!-- SECTION 1: FOUNDATIONS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üß±</span> 1. Graph Foundations
        </div>
        
        <div class="collapsible">
          <strong>What is a Graph?</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">A graph is a non-linear data structure consisting of <strong>Nodes (Vertices)</strong> and <strong>Edges</strong> (connections between nodes).</p>
          <div class="code-block" style="background: transparent; border: none;">
            <pre style="color: var(--accent-color);">
    (A) <--- Node (Vertex)
   /   \
  /     \  <--- Edge
(B)-----(C)
            </pre>
          </div>
          <p style="color: var(--text-secondary);"><strong>Formal Definition:</strong> G = (V, E), where V is a set of vertices and E is a set of edges.</p>
        </div>

        <div class="collapsible">
          <strong>Types of Graphs (Interview Critical)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <table class="complexity-table">
            <thead><tr><th>Type</th><th>Visual</th><th>Description</th><th>Real World</th></tr></thead>
            <tbody>
              <tr>
                <td><strong>Undirected</strong></td>
                <td>A ‚Äî B</td>
                <td>Edges have no direction. (A,B) == (B,A).</td>
                <td>Facebook Friends</td>
              </tr>
              <tr>
                <td><strong>Directed</strong></td>
                <td>A ‚Üí B</td>
                <td>Edges have direction. (A,B) != (B,A).</td>
                <td>Twitter Follows, URLs</td>
              </tr>
              <tr>
                <td><strong>Weighted</strong></td>
                <td>A ‚Äî[5]‚Äî B</td>
                <td>Edges have values (cost, distance).</td>
                <td>Google Maps (Distance)</td>
              </tr>
              <tr>
                <td><strong>Cyclic</strong></td>
                <td>A‚ÜíB‚ÜíC‚ÜíA</td>
                <td>Contains at least one cycle.</td>
                <td>Infinite Loops, Deadlocks</td>
              </tr>
              <tr>
                <td><strong>DAG</strong></td>
                <td>A‚ÜíB, A‚ÜíC</td>
                <td>Directed Acyclic Graph. No cycles.</td>
                <td>Build Systems, Task Scheduling</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- SECTION 2: REPRESENTATION -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üíæ</span> 2. Graph Representation
        </div>
        <p style="color: var(--text-secondary); margin-bottom: 15px;">A Graph is a non-linear data structure consisting of vertices (V) and edges (E). Here are the two most common ways to represent a graph.</p>

        <div class="collapsible">
          <strong>1. Adjacency Matrix</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">An adjacency matrix is a 2D boolean matrix of size <code>V x V</code>. If there is an edge from vertex <code>i</code> to <code>j</code>, we mark <code>adjMat[i][j] = 1</code>, otherwise <code>0</code>.</p>
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Space:</strong> O(V¬≤) - Heavy memory usage.</li>
            <li><strong>Time (Check Edge):</strong> O(1) - Instant lookup.</li>
            <li><strong>Verdict:</strong> Use only for dense graphs or when V is small.</li>
          </ul>

          <h4 style="color: var(--text-primary); margin-top: 15px;">Undirected Graph</h4>
          <p style="color: var(--text-secondary);">Edges are bidirectional. If <code>0-1</code> exists, set <code>mat[0][1]=1</code> and <code>mat[1][0]=1</code>.</p>
          <div class="code-block"><pre>
func createUndirectedMatrix(n int, edges [][]int) [][]int {
    mat := make([][]int, n)
    for i := range mat { mat[i] = make([]int, n) }
    
    for _, e := range edges {
        u, v := e[0], e[1]
        mat[u][v] = 1
        mat[v][u] = 1 // Symmetric
    }
    return mat
}</pre></div>

          <h4 style="color: var(--text-primary); margin-top: 15px;">Directed Graph</h4>
          <p style="color: var(--text-secondary);">Edges are unidirectional. If <code>1->0</code> exists, set <code>mat[1][0]=1</code> only.</p>
          <div class="code-block"><pre>
func createDirectedMatrix(n int, edges [][]int) [][]int {
    mat := make([][]int, n)
    for i := range mat { mat[i] = make([]int, n) }
    
    for _, e := range edges {
        u, v := e[0], e[1]
        mat[u][v] = 1 // One way
    }
    return mat
}</pre></div>
        </div>

        <div class="collapsible">
          <strong>2. Adjacency List (Preferred)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">An array of lists (or map of lists). Each index <code>i</code> stores a list of vertices adjacent to it.</p>
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Space:</strong> O(V + E) - Efficient for sparse graphs.</li>
            <li><strong>Time (Check Edge):</strong> O(Degree of V).</li>
            <li><strong>Verdict:</strong> Use this for 95% of interview problems.</li>
          </ul>

          <h4 style="color: var(--text-primary); margin-top: 15px;">Undirected Graph</h4>
          <p style="color: var(--text-secondary);">For edge <code>0-1</code>, add <code>1</code> to <code>adj[0]</code> and <code>0</code> to <code>adj[1]</code>.</p>
          <div class="code-block"><pre>
func createUndirectedList(n int, edges [][]int) [][]int {
    adj := make([][]int, n)
    for _, e := range edges {
        u, v := e[0], e[1]
        adj[u] = append(adj[u], v)
        adj[v] = append(adj[v], u) // Symmetric
    }
    return adj
}</pre></div>

          <h4 style="color: var(--text-primary); margin-top: 15px;">Directed Graph</h4>
          <p style="color: var(--text-secondary);">For edge <code>1->0</code>, add <code>0</code> to <code>adj[1]</code> only.</p>
          <div class="code-block"><pre>
func createDirectedList(n int, edges [][]int) [][]int {
    adj := make([][]int, n)
    for _, e := range edges {
        u, v := e[0], e[1]
        adj[u] = append(adj[u], v)
    }
    return adj
}</pre></div>
        </div>
      </div>

      <!-- SECTION 3: TRAVERSAL -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üö∂</span> 3. Graph Traversal (Core)
        </div>

        <!-- BFS -->
        <div class="collapsible">
          <strong>Breadth-First Search (BFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <div class="callout amazon-expects">
            <div class="callout-title">When to use BFS?</div>
            <div class="callout-content">
              <ul>
                <li>Finding the <strong>shortest path</strong> in an unweighted graph.</li>
                <li>Level-order traversal (layer by layer).</li>
                <li>Connected components in undirected graphs.</li>
              </ul>
            </div>
          </div>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Queue (FIFO).</p>
          
          <strong style="color: var(--text-primary);">Go Implementation</strong>
          <div class="code-block"><pre>
func bfs(start int, graph map[int][]int) {
    queue := []int{start}
    visited := make(map[int]bool)
    visited[start] = true

    for len(queue) > 0 {
        // Dequeue
        node := queue[0]
        queue = queue[1:]
        
        // Process node
        fmt.Println("Visited:", node)

        // Enqueue neighbors
        for _, neighbor := range graph[node] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
}</pre></div>
        </div>

        <!-- DFS -->
        <div class="collapsible">
          <strong>Depth-First Search (DFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <div class="callout amazon-expects">
            <div class="callout-title">When to use DFS?</div>
            <div class="callout-content">
              <ul>
                <li>Pathfinding (does a path exist?).</li>
                <li>Cycle detection.</li>
                <li>Topological sorting.</li>
                <li>Solving mazes / puzzles.</li>
              </ul>
            </div>
          </div>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Stack (LIFO) or Recursion.</p>

          <strong style="color: var(--text-primary);">Go Implementation (Recursive)</strong>
          <div class="code-block"><pre>
func dfs(node int, graph map[int][]int, visited map[int]bool) {
    if visited[node] {
        return
    }
    visited[node] = true
    fmt.Println("Visited:", node)

    for _, neighbor := range graph[node] {
        dfs(neighbor, graph, visited)
    }
}</pre></div>
        </div>
      </div>

      <!-- SECTION 4: MATRIX GRAPHS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">‚ñ¶</span> 4. Matrix Graphs (Grid Problems)
        </div>
        <div class="callout key-intuition">
          <div class="callout-title">Implicit Graphs</div>
          <div class="callout-content">
            <p>A 2D matrix is a graph where:</p>
            <ul>
              <li><strong>Nodes:</strong> Cells <code>(r, c)</code></li>
              <li><strong>Edges:</strong> Connections to adjacent cells (Up, Down, Left, Right)</li>
            </ul>
            <p><strong>Common Pattern:</strong> Use a <code>directions</code> array to navigate neighbors.</p>
          </div>
        </div>

        <div class="collapsible">
          <strong>1. Number of Islands (DFS/BFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Count connected components of '1's (land).</p>
          <p style="color: var(--text-secondary);"><strong>Approach:</strong> Iterate through matrix. When '1' is found, increment count and trigger DFS/BFS to mark all connected '1's as '0' (visited).</p>
          
          <div class="code-block"><pre>
func numIslands(grid [][]byte) int {
    if len(grid) == 0 { return 0 }
    rows, cols := len(grid), len(grid[0])
    count := 0
    
    var dfs func(r, c int)
    dfs = func(r, c int) {
        // Boundary check and visited check
        if r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] == '0' {
            return
        }
        grid[r][c] = '0' // Mark visited
        
        // Visit neighbors
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    }
    
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == '1' {
                count++
                dfs(r, c)
            }
        }
    }
    return count
}</pre></div>
        </div>

        <div class="collapsible">
          <strong>2. Rotting Oranges (Multi-Source BFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Min minutes until all fresh oranges rot. Rotten oranges affect neighbors every minute.</p>
          <p style="color: var(--text-secondary);"><strong>Approach:</strong> Use BFS. Add all initially rotten oranges to Queue (Level 0). Process level by level.</p>
          
          <div class="code-block"><pre>
func orangesRotting(grid [][]int) int {
    rows, cols := len(grid), len(grid[0])
    queue := [][2]int{}
    fresh := 0
    
    // Init queue with all rotten oranges
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == 2 {
                queue = append(queue, [2]int{r, c})
            } else if grid[r][c] == 1 {
                fresh++
            }
        }
    }
    
    minutes := 0
    dirs := [][2]int{{0,1}, {0,-1}, {1,0}, {-1,0}}
    
    for len(queue) > 0 && fresh > 0 {
        minutes++
        size := len(queue)
        for i := 0; i < size; i++ {
            curr := queue[0]
            queue = queue[1:]
            
            for _, d := range dirs {
                nr, nc := curr[0]+d[0], curr[1]+d[1]
                if nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1 {
                    grid[nr][nc] = 2 // Rot it
                    fresh--
                    queue = append(queue, [2]int{nr, nc})
                }
            }
        }
    }
    
    if fresh > 0 { return -1 }
    return minutes
}</pre></div>
        </div>
      </div>

      <!-- SECTION 5: ALGORITHMS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">‚ö°</span> 5. Important Graph Algorithms
        </div>

        <!-- TOPOLOGICAL SORT -->
        <div class="collapsible">
          <strong>1. Topological Sort (Kahn's Algorithm)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Order tasks such that for every dependency A -> B, A comes before B.</p>
          <p style="color: var(--text-secondary);"><strong>Requirement:</strong> Graph must be a DAG (Directed Acyclic Graph).</p>
          <p style="color: var(--text-secondary);"><strong>Real World:</strong> Build systems (Makefiles), Course prerequisites.</p>
          
          <strong style="color: var(--text-primary);">Algorithm (BFS based):</strong>
          <ol style="margin-left: 20px; color: var(--text-secondary);">
            <li>Calculate <strong>in-degree</strong> (number of incoming edges) for all nodes.</li>
            <li>Add nodes with <code>in-degree == 0</code> to a Queue.</li>
            <li>While Queue is not empty:
                <ul>
                    <li>Pop node, add to result.</li>
                    <li>Reduce in-degree of neighbors.</li>
                    <li>If neighbor's in-degree becomes 0, push to Queue.</li>
                </ul>
            </li>
          </ol>

          <div class="code-block"><pre>
func topologicalSort(n int, edges [][]int) []int {
    inDegree := make([]int, n)
    graph := make(map[int][]int)
    for _, e := range edges {
        graph[e[0]] = append(graph[e[0]], e[1])
        inDegree[e[1]]++
    }

    queue := []int{}
    for i := 0; i < n; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }

    var result []int
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)

        for _, neighbor := range graph[node] {
            inDegree[neighbor]--
            if inDegree[neighbor] == 0 {
                queue = append(queue, neighbor)
            }
        }
    }
    
    if len(result) != n { return []int{} } // Cycle detected
    return result
}</pre></div>
        </div>

        <!-- DIJKSTRA -->
        <div class="collapsible">
          <strong>2. Dijkstra's Algorithm (Shortest Path)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Shortest path from Source to all other nodes in a <strong>weighted</strong> graph (non-negative weights).</p>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Min-Priority Queue (Min-Heap).</p>
          <p style="color: var(--text-secondary);"><strong>Complexity:</strong> O(E log V).</p>

          <strong style="color: var(--text-primary);">Algorithm:</strong>
          <ol style="margin-left: 20px; color: var(--text-secondary);">
            <li>Set distance to start = 0, all others = infinity.</li>
            <li>Push (0, start) to Min-Heap.</li>
            <li>While Heap not empty:
                <ul>
                    <li>Pop node with smallest distance.</li>
                    <li>If current distance > stored distance, skip (stale entry).</li>
                    <li>For each neighbor:
                        <ul>
                            <li>newDist = dist + weight.</li>
                            <li>If newDist < neighborDist: Update and Push.</li>
                        </ul>
                    </li>
                </ul>
            </li>
          </ol>
        </div>

        <!-- UNION FIND -->
        <div class="collapsible">
          <strong>3. Union-Find (Disjoint Set)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Use Case:</strong> Detecting cycles in undirected graphs, Kruskal's MST, Connected components.</p>
          <p style="color: var(--text-secondary);"><strong>Operations:</strong> <code>Find(x)</code>, <code>Union(x, y)</code>.</p>
          <p style="color: var(--text-secondary);"><strong>Optimization:</strong> Path Compression + Union by Rank -> O(Œ±(n)) ‚âà O(1).</p>

          <div class="code-block"><pre>
type UnionFind struct {
    parent []int
}

func NewUnionFind(n int) *UnionFind {
    p := make([]int, n)
    for i := range p { p[i] = i }
    return &UnionFind{parent: p}
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x]) // Path compression
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX == rootY { return false } // Already connected
    uf.parent[rootX] = rootY
    return true
}</pre></div>
        </div>

        <!-- CYCLE DETECTION -->
        <div class="collapsible">
          <strong>4. Cycle Detection</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Undirected Graph:</strong> Use BFS/DFS or Union-Find. If you hit a visited node that isn't your parent, cycle exists.</li>
            <li><strong>Directed Graph:</strong> Use DFS with 3 states (0=Unvisited, 1=Visiting, 2=Visited). If you hit a node in state 1 (Visiting), cycle exists (Back edge).</li>
          </ul>
        </div>
      </div>

      <!-- SECTION 6: ADVANCED -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üéì</span> 6. Advanced Topics (SDE-2+)
        </div>
        <div class="callout" style="background-color: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Bellman-Ford:</strong> Shortest path with negative weights. Detects negative cycles. O(VE).</li>
            <li><strong>Floyd-Warshall:</strong> All-pairs shortest path. O(V¬≥).</li>
            <li><strong>Prim's & Kruskal's:</strong> Minimum Spanning Tree (MST). Connect all nodes with min cost.</li>
            <li><strong>Bridges & Articulation Points:</strong> Critical edges/nodes whose removal disconnects the graph. (Tarjan's Algo).</li>
            <li><strong>Max Flow (Ford-Fulkerson):</strong> Max amount of "stuff" moved from source to sink.</li>
          </ul>
        </div>
      </div>

      <!-- SECTION 7: REAL WORLD -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üåç</span> 7. Real-World Mapping
        </div>
        <table class="complexity-table">
          <thead><tr><th>System</th><th>Graph Representation</th><th>Algorithm</th></tr></thead>
          <tbody>
            <tr><td><strong>Google Maps</strong></td><td>Weighted Graph (Nodes=Intersections, Edges=Roads)</td><td>Dijkstra / A* (Pathfinding)</td></tr>
            <tr><td><strong>Social Network</strong></td><td>Undirected (Friends) or Directed (Follows)</td><td>BFS (Degrees of separation)</td></tr>
            <tr><td><strong>Web Crawler</strong></td><td>Directed Graph (URLs)</td><td>BFS/DFS (Traversal)</td></tr>
            <tr><td><strong>Excel Formula</strong></td><td>DAG (Dependencies)</td><td>Topological Sort (Calc order)</td></tr>
            <tr><td><strong>Uber/Lyft</strong></td><td>Dynamic Weighted Graph</td><td>Shortest Path + Matching</td></tr>
          </tbody>
        </table>
      </div>

      <!-- SECTION 8: PATTERNS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üß†</span> 8. Interview Decision Table
        </div>
        <div class="callout interview-tip">
          <div class="callout-title">Which Algorithm to Choose?</div>
          <div class="callout-content">
            <ul style="line-height: 1.8;">
              <li><strong>Shortest Path (Unweighted):</strong> BFS</li>
              <li><strong>Shortest Path (Weighted, Positive):</strong> Dijkstra</li>
              <li><strong>Shortest Path (Weighted, Negative):</strong> Bellman-Ford</li>
              <li><strong>Connectivity / Cycles (Undirected):</strong> Union-Find or DFS</li>
              <li><strong>Dependency Resolution:</strong> Topological Sort</li>
              <li><strong>Maze / Grid Problems:</strong> BFS (shortest path) or DFS (existence)</li>
              <li><strong>"Is it bipartite?":</strong> BFS with 2-coloring</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- SECTION 9: SUMMARY -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">‚úÖ</span> 9. Final Summary
        </div>
        <div class="callout amazon-expects">
          <div class="callout-title">Before the Interview</div>
          <div class="callout-content">
            <ul>
              <li>Can you implement BFS and DFS from scratch without hesitation?</li>
              <li>Do you know how to represent a graph using an Adjacency List (Map/Array)?</li>
              <li>Can you detect a cycle in both directed and undirected graphs?</li>
              <li>Do you understand when to use Dijkstra vs BFS?</li>
            </ul>
          </div>
        </div>
      </div>

    </main>
  </div>
  <script src="../script.js"></script>
</body>
</html>