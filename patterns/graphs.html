<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graph Algorithms - Amazon SDE Prep</title>
  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>üåë Amazon SDE</h1>
        <p>Coding Interview Prep</p>
      </div>
      <div class="nav-section">
        <div class="nav-section-title">Learning Resources</div>
        <a href="../pattern-recognition-guide.html" class="nav-item">Pattern Recognition</a>
        <a href="../interview-approach.html" class="nav-item">Interview Approach</a>
        <a href="../complexity-guide.html" class="nav-item">Complexity Analysis</a>
        <a href="../dsa-roadmap.html" class="nav-item">DSA Roadmap</a>
        <a href="../system-design.html" class="nav-item">System Design Basics</a>
      </div>
      <div class="nav-section">
        <div class="nav-section-title">Data Structures</div>
        <a href="linked-lists.html" class="nav-item">Linked Lists</a>
        <a href="trees.html" class="nav-item">Trees</a>
        <a href="graphs.html" class="nav-item active">Graphs</a>
        <a href="heap.html" class="nav-item">Heap</a>
      </div>
      <div class="nav-section">
        <div class="nav-section-title">Back to Home</div>
        <a href="../index.html" class="nav-item">‚Üê Dashboard</a>
      </div>
    </aside>

    <main class="main-content">
      <div class="content-header">
        <h1>üï∏Ô∏è Graph Algorithms Masterclass</h1>
        <p>The backbone of Google Maps, Social Networks, and the Internet.</p>
      </div>

      <!-- SECTION 1: FOUNDATIONS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üß±</span> 1. Graph Foundations
        </div>
        
        <div class="collapsible">
          <strong>What is a Graph?</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">A graph is a non-linear data structure consisting of <strong>Nodes (Vertices)</strong> and <strong>Edges</strong> (connections between nodes).</p>
          <div class="code-block" style="background: transparent; border: none;">
            <pre style="color: var(--accent-color);">
    (A) <--- Node (Vertex)
   /   \
  /     \  <--- Edge
(B)-----(C)
            </pre>
          </div>
          <p style="color: var(--text-secondary);"><strong>Formal Definition:</strong> G = (V, E), where V is a set of vertices and E is a set of edges.</p>
        </div>

        <div class="collapsible">
          <strong>Types of Graphs (Interview Critical)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <table class="complexity-table">
            <thead><tr><th>Type</th><th>Visual</th><th>Description</th><th>Real World</th></tr></thead>
            <tbody>
              <tr>
                <td><strong>Undirected</strong></td>
                <td>A ‚Äî B</td>
                <td>Edges have no direction. (A,B) == (B,A).</td>
                <td>Facebook Friends</td>
              </tr>
              <tr>
                <td><strong>Directed</strong></td>
                <td>A ‚Üí B</td>
                <td>Edges have direction. (A,B) != (B,A).</td>
                <td>Twitter Follows, URLs</td>
              </tr>
              <tr>
                <td><strong>Weighted</strong></td>
                <td>A ‚Äî[5]‚Äî B</td>
                <td>Edges have values (cost, distance).</td>
                <td>Google Maps (Distance)</td>
              </tr>
              <tr>
                <td><strong>Cyclic</strong></td>
                <td>A‚ÜíB‚ÜíC‚ÜíA</td>
                <td>Contains at least one cycle.</td>
                <td>Infinite Loops, Deadlocks</td>
              </tr>
              <tr>
                <td><strong>DAG</strong></td>
                <td>A‚ÜíB, A‚ÜíC</td>
                <td>Directed Acyclic Graph. No cycles.</td>
                <td>Build Systems, Task Scheduling</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- SECTION 2: REPRESENTATION -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üíæ</span> 2. Graph Representation
        </div>
        <p style="color: var(--text-secondary); margin-bottom: 15px;">How do we store a graph in code? This is the first decision you make in an interview.</p>

        <div class="collapsible">
          <strong>1. Adjacency List (Preferred)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">An array of lists (or map of lists). Each node stores a list of its neighbors.</p>
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Space:</strong> O(V + E) - Efficient for sparse graphs.</li>
            <li><strong>Time (Check Edge):</strong> O(Degree of V).</li>
            <li><strong>Verdict:</strong> Use this for 95% of interview problems.</li>
          </ul>
          
          <div style="background-color: var(--bg-tertiary); padding: 10px; border-radius: 8px; margin-top: 10px;">
            <strong style="color: #3b82f6;">Go Implementation</strong>
            <div class="code-block"><pre>
// Map is easiest for generic keys (strings/ints)
graph := make(map[int][]int)

// Add Edge (0 -> 1)
graph[0] = append(graph[0], 1)

// Add Undirected (0 <-> 1)
graph[0] = append(graph[0], 1)
graph[1] = append(graph[1], 0)</pre></div>
          </div>
        </div>

        <div class="collapsible">
          <strong>2. Adjacency Matrix</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);">A 2D array <code>matrix[i][j]</code>. 1 if edge exists, 0 otherwise.</p>
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Space:</strong> O(V¬≤) - Heavy memory usage.</li>
            <li><strong>Time (Check Edge):</strong> O(1) - Instant lookup.</li>
            <li><strong>Verdict:</strong> Use only for dense graphs or when V is small (< 5000).</li>
          </ul>
        </div>
      </div>

      <!-- SECTION 3: TRAVERSAL -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üö∂</span> 3. Graph Traversal (Core)
        </div>

        <!-- BFS -->
        <div class="collapsible">
          <strong>Breadth-First Search (BFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <div class="callout amazon-expects">
            <div class="callout-title">When to use BFS?</div>
            <div class="callout-content">
              <ul>
                <li>Finding the <strong>shortest path</strong> in an unweighted graph.</li>
                <li>Level-order traversal (layer by layer).</li>
                <li>Connected components in undirected graphs.</li>
              </ul>
            </div>
          </div>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Queue (FIFO).</p>
          
          <strong style="color: var(--text-primary);">Go Implementation</strong>
          <div class="code-block"><pre>
func bfs(start int, graph map[int][]int) {
    queue := []int{start}
    visited := make(map[int]bool)
    visited[start] = true

    for len(queue) > 0 {
        // Dequeue
        node := queue[0]
        queue = queue[1:]
        
        // Process node
        fmt.Println("Visited:", node)

        // Enqueue neighbors
        for _, neighbor := range graph[node] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
}</pre></div>
        </div>

        <!-- DFS -->
        <div class="collapsible">
          <strong>Depth-First Search (DFS)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <div class="callout amazon-expects">
            <div class="callout-title">When to use DFS?</div>
            <div class="callout-content">
              <ul>
                <li>Pathfinding (does a path exist?).</li>
                <li>Cycle detection.</li>
                <li>Topological sorting.</li>
                <li>Solving mazes / puzzles.</li>
              </ul>
            </div>
          </div>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Stack (LIFO) or Recursion.</p>

          <strong style="color: var(--text-primary);">Go Implementation (Recursive)</strong>
          <div class="code-block"><pre>
func dfs(node int, graph map[int][]int, visited map[int]bool) {
    if visited[node] {
        return
    }
    visited[node] = true
    fmt.Println("Visited:", node)

    for _, neighbor := range graph[node] {
        dfs(neighbor, graph, visited)
    }
}</pre></div>
        </div>
      </div>

      <!-- SECTION 4: ALGORITHMS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">‚ö°</span> 4. Important Graph Algorithms
        </div>

        <!-- TOPOLOGICAL SORT -->
        <div class="collapsible">
          <strong>1. Topological Sort (Kahn's Algorithm)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Order tasks such that for every dependency A -> B, A comes before B.</p>
          <p style="color: var(--text-secondary);"><strong>Requirement:</strong> Graph must be a DAG (Directed Acyclic Graph).</p>
          <p style="color: var(--text-secondary);"><strong>Real World:</strong> Build systems (Makefiles), Course prerequisites.</p>
          
          <strong style="color: var(--text-primary);">Algorithm (BFS based):</strong>
          <ol style="margin-left: 20px; color: var(--text-secondary);">
            <li>Calculate <strong>in-degree</strong> (number of incoming edges) for all nodes.</li>
            <li>Add nodes with <code>in-degree == 0</code> to a Queue.</li>
            <li>While Queue is not empty:
                <ul>
                    <li>Pop node, add to result.</li>
                    <li>Reduce in-degree of neighbors.</li>
                    <li>If neighbor's in-degree becomes 0, push to Queue.</li>
                </ul>
            </li>
          </ol>

          <div class="code-block"><pre>
func topologicalSort(n int, edges [][]int) []int {
    inDegree := make([]int, n)
    graph := make(map[int][]int)
    for _, e := range edges {
        graph[e[0]] = append(graph[e[0]], e[1])
        inDegree[e[1]]++
    }

    queue := []int{}
    for i := 0; i < n; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }

    var result []int
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)

        for _, neighbor := range graph[node] {
            inDegree[neighbor]--
            if inDegree[neighbor] == 0 {
                queue = append(queue, neighbor)
            }
        }
    }
    
    if len(result) != n { return []int{} } // Cycle detected
    return result
}</pre></div>
        </div>

        <!-- DIJKSTRA -->
        <div class="collapsible">
          <strong>2. Dijkstra's Algorithm (Shortest Path)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Problem:</strong> Shortest path from Source to all other nodes in a <strong>weighted</strong> graph (non-negative weights).</p>
          <p style="color: var(--text-secondary);"><strong>Data Structure:</strong> Min-Priority Queue (Min-Heap).</p>
          <p style="color: var(--text-secondary);"><strong>Complexity:</strong> O(E log V).</p>

          <strong style="color: var(--text-primary);">Algorithm:</strong>
          <ol style="margin-left: 20px; color: var(--text-secondary);">
            <li>Set distance to start = 0, all others = infinity.</li>
            <li>Push (0, start) to Min-Heap.</li>
            <li>While Heap not empty:
                <ul>
                    <li>Pop node with smallest distance.</li>
                    <li>If current distance > stored distance, skip (stale entry).</li>
                    <li>For each neighbor:
                        <ul>
                            <li>newDist = dist + weight.</li>
                            <li>If newDist < neighborDist: Update and Push.</li>
                        </ul>
                    </li>
                </ul>
            </li>
          </ol>
        </div>

        <!-- UNION FIND -->
        <div class="collapsible">
          <strong>3. Union-Find (Disjoint Set)</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <p style="color: var(--text-secondary);"><strong>Use Case:</strong> Detecting cycles in undirected graphs, Kruskal's MST, Connected components.</p>
          <p style="color: var(--text-secondary);"><strong>Operations:</strong> <code>Find(x)</code>, <code>Union(x, y)</code>.</p>
          <p style="color: var(--text-secondary);"><strong>Optimization:</strong> Path Compression + Union by Rank -> O(Œ±(n)) ‚âà O(1).</p>

          <div class="code-block"><pre>
type UnionFind struct {
    parent []int
}

func NewUnionFind(n int) *UnionFind {
    p := make([]int, n)
    for i := range p { p[i] = i }
    return &UnionFind{parent: p}
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x]) // Path compression
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX == rootY { return false } // Already connected
    uf.parent[rootX] = rootY
    return true
}</pre></div>
        </div>

        <!-- CYCLE DETECTION -->
        <div class="collapsible">
          <strong>4. Cycle Detection</strong>
          <span class="collapsible-icon">‚ñº</span>
        </div>
        <div class="collapsible-content">
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Undirected Graph:</strong> Use BFS/DFS or Union-Find. If you hit a visited node that isn't your parent, cycle exists.</li>
            <li><strong>Directed Graph:</strong> Use DFS with 3 states (0=Unvisited, 1=Visiting, 2=Visited). If you hit a node in state 1 (Visiting), cycle exists (Back edge).</li>
          </ul>
        </div>
      </div>

      <!-- SECTION 5: ADVANCED -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üéì</span> 5. Advanced Topics (SDE-2+)
        </div>
        <div class="callout" style="background-color: var(--bg-tertiary); padding: 20px; border-radius: 8px;">
          <ul style="margin-left: 20px; color: var(--text-secondary);">
            <li><strong>Bellman-Ford:</strong> Shortest path with negative weights. Detects negative cycles. O(VE).</li>
            <li><strong>Floyd-Warshall:</strong> All-pairs shortest path. O(V¬≥).</li>
            <li><strong>Prim's & Kruskal's:</strong> Minimum Spanning Tree (MST). Connect all nodes with min cost.</li>
            <li><strong>Bridges & Articulation Points:</strong> Critical edges/nodes whose removal disconnects the graph. (Tarjan's Algo).</li>
            <li><strong>Max Flow (Ford-Fulkerson):</strong> Max amount of "stuff" moved from source to sink.</li>
          </ul>
        </div>
      </div>

      <!-- SECTION 6: REAL WORLD -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üåç</span> 6. Real-World Mapping
        </div>
        <table class="complexity-table">
          <thead><tr><th>System</th><th>Graph Representation</th><th>Algorithm</th></tr></thead>
          <tbody>
            <tr><td><strong>Google Maps</strong></td><td>Weighted Graph (Nodes=Intersections, Edges=Roads)</td><td>Dijkstra / A* (Pathfinding)</td></tr>
            <tr><td><strong>Social Network</strong></td><td>Undirected (Friends) or Directed (Follows)</td><td>BFS (Degrees of separation)</td></tr>
            <tr><td><strong>Web Crawler</strong></td><td>Directed Graph (URLs)</td><td>BFS/DFS (Traversal)</td></tr>
            <tr><td><strong>Excel Formula</strong></td><td>DAG (Dependencies)</td><td>Topological Sort (Calc order)</td></tr>
            <tr><td><strong>Uber/Lyft</strong></td><td>Dynamic Weighted Graph</td><td>Shortest Path + Matching</td></tr>
          </tbody>
        </table>
      </div>

      <!-- SECTION 7: PATTERNS -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">üß†</span> 7. Interview Decision Table
        </div>
        <div class="callout interview-tip">
          <div class="callout-title">Which Algorithm to Choose?</div>
          <div class="callout-content">
            <ul style="line-height: 1.8;">
              <li><strong>Shortest Path (Unweighted):</strong> BFS</li>
              <li><strong>Shortest Path (Weighted, Positive):</strong> Dijkstra</li>
              <li><strong>Shortest Path (Weighted, Negative):</strong> Bellman-Ford</li>
              <li><strong>Connectivity / Cycles (Undirected):</strong> Union-Find or DFS</li>
              <li><strong>Dependency Resolution:</strong> Topological Sort</li>
              <li><strong>Maze / Grid Problems:</strong> BFS (shortest path) or DFS (existence)</li>
              <li><strong>"Is it bipartite?":</strong> BFS with 2-coloring</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- SECTION 8: SUMMARY -->
      <div class="section">
        <div class="section-title">
          <span class="emoji">‚úÖ</span> 8. Final Summary
        </div>
        <div class="callout amazon-expects">
          <div class="callout-title">Before the Interview</div>
          <div class="callout-content">
            <ul>
              <li>Can you implement BFS and DFS from scratch without hesitation?</li>
              <li>Do you know how to represent a graph using an Adjacency List (Map/Array)?</li>
              <li>Can you detect a cycle in both directed and undirected graphs?</li>
              <li>Do you understand when to use Dijkstra vs BFS?</li>
            </ul>
          </div>
        </div>
      </div>

    </main>
  </div>
  <script src="../script.js"></script>
</body>
</html>