<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked List Operations Visualizer - Software Systems Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <style>
        /* Specific styles for Linked List Visualizer */
        .memory-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
        }
        .memory-block {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 8px;
            font-size: 0.8rem;
            color: var(--text-muted);
            position: relative;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .memory-block.occupied {
            border-color: var(--accent-color);
            background: rgba(59, 130, 246, 0.1);
            color: var(--text-primary);
        }
        .memory-block.highlight {
            background: rgba(250, 204, 21, 0.2);
            border-color: #facc15;
        }
        .memory-addr {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.65rem;
            color: var(--text-muted);
            font-family: monospace;
        }
        .memory-val { font-weight: bold; font-size: 1.1rem; }
        .memory-next { font-size: 0.7rem; color: var(--callout-green); margin-top: 2px; font-family: monospace; }

        .node-rect { fill: var(--bg-tertiary); stroke: var(--accent-color); stroke-width: 2; transition: all 0.5s ease; }
        .node-text { fill: var(--text-primary); font-weight: bold; font-family: monospace; font-size: 14px; text-anchor: middle; dominant-baseline: middle; }
        .ptr-text { fill: var(--text-muted); font-size: 12px; font-family: monospace; }
        
        .control-input {
            width: 100%;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .canvas-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            cursor: grab;
            user-select: none;
        }
        .canvas-wrapper.active {
            cursor: grabbing;
        }

        #ll-svg {
            min-width: 100%;
            cursor: inherit;
        }
        .code-line.active {
            background-color: rgba(250, 204, 21, 0.2);
            border-left: 3px solid #facc15;
            color: #facc15;
        }
        /* Code Panel Styles */
        .split-view {
            display: flex;
            gap: 20px;
            height: 100%;
            min-height: 400px;
        }
        .canvas-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        .code-section {
            flex: 1;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 300px;
        }
        .code-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(255,255,255,0.05);
        }
        .algo-code {
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            flex: 1;
        }
        .code-line { padding: 2px 5px; border-radius: 4px; }
        .ln { color: var(--text-muted); margin-right: 10px; user-select: none; }
        .kwd { color: #f472b6; } .com { color: #6b7280; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë Software Systems</h1>
                <p>Linked List Ops</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Back</div>
                <a href="../index.html" class="nav-item">‚Üê Dashboard</a>
                <a href="linked-lists.html" class="nav-item">‚Üê Linked Lists Pattern</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Controls</div>
                <div class="control-group">
                    <div class="toggle-row">
                        <span>Doubly Linked List</span>
                        <label class="switch">
                            <input type="checkbox" id="dll-toggle" onchange="toggleDLL()">
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <label>Value</label>
                    <input type="number" id="val-input" class="control-input" placeholder="Enter value..." value="10">
                    <button class="action-btn" onclick="insertHead()">Insert at Head</button>
                    <button class="action-btn" onclick="insertTail()">Insert at Tail</button>
                    <button class="action-btn" onclick="searchNode()">Search Value</button>
                    <button class="action-btn danger" onclick="deleteNode()">Delete Value</button>
                </div>
                <div class="control-group">
                    <button class="action-btn warning" onclick="resetList()">Reset List</button>
                </div>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar">
                    <div id="status-text" style="font-family: monospace; color: var(--accent-color);">Ready. Nodes are allocated non-contiguously in Heap Memory.</div>
                </div>
                
                <div class="split-view">
                    <!-- Visualization -->
                    <div class="canvas-section">
                        <div style="padding: 10px; border-bottom: 1px solid var(--border-color); background: var(--bg-secondary);">
                            <strong style="color: var(--text-primary);">Logical View</strong> (Pointers)
                        </div>
                        <div class="canvas-wrapper" id="logical-view-container" style="flex: 2; min-height: 250px;">
                            <svg id="ll-svg" width="100%" height="100%"></svg>
                        </div>
                        <div style="padding: 10px; border-top: 1px solid var(--border-color); background: var(--bg-secondary);">
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px; display: flex; justify-content: space-between;">
                                <span><strong>Physical View</strong> (Heap Memory Simulation)</span>
                                <span style="font-size: 0.8rem; color: var(--text-muted);">Random Addresses</span>
                            </div>
                            <div id="memory-view" class="memory-container">
                                <!-- Memory blocks injected here -->
                            </div>
                        </div>
                    </div>

                    <!-- Code Panel -->
                    <div class="code-section">
                        <div class="code-header">
                            <button class="action-btn" style="padding: 4px 10px; font-size: 0.8rem;" onclick="copyCode()">üìã Copy</button>
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go')">Go</button>
                                <button class="tab-btn" onclick="switchLang('java')">Java</button>
                                <button class="tab-btn" onclick="switchLang('python')">Python</button>
                            </div>
                        </div>
                        <div id="code-display" class="algo-code"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Memory Simulation
        const MEMORY_SIZE = 24;
        const memorySlots = Array(MEMORY_SIZE).fill(null);
        let head = null;
        let isDLL = false;
        let isAnimating = false;
        let currentLang = 'go';
        let currentOp = 'insertHead';

        // DOM Elements
        const logicalContainer = document.getElementById('logical-view-container');
        const svg = document.getElementById('ll-svg');
        const memoryView = document.getElementById('memory-view');
        const statusText = document.getElementById('status-text');
        const input = document.getElementById('val-input');
        const codeDisplay = document.getElementById('code-display');

        // Code Snippets
        const CODES = {
            insertHead: {
                go: `func insertHead(head *Node, val int) *Node {
    newNode := &Node{Val: val} // Allocates memory
    newNode.Next = head        // Point to old head
    return newNode             // New head
}`,
                java: `public Node insertHead(Node head, int val) {
    Node newNode = new Node(val); // Heap allocation
    newNode.next = head;
    return newNode;
}`,
                python: `def insert_head(head, val):
    new_node = Node(val) # Heap object
    new_node.next = head
    return new_node`
            },
            insertTail: {
                go: `func insertTail(head *Node, val int) *Node {
    newNode := &Node{Val: val}
    if head == nil { return newNode }
    curr := head
    for curr.Next != nil {
        curr = curr.Next
    }
    curr.Next = newNode
    return head
}`,
                java: `public Node insertTail(Node head, int val) {
    Node newNode = new Node(val);
    if (head == null) return newNode;
    Node curr = head;
    while (curr.next != null) {
        curr = curr.next;
    }
    curr.next = newNode;
    return head;
}`,
                python: `def insert_tail(head, val):
    new_node = Node(val)
    if not head: return new_node
    curr = head
    while curr.next:
        curr = curr.next
    curr.next = new_node
    return head`
            },
            delete: {
                go: `func delete(head *Node, val int) *Node {
    if head == nil { return nil }
    if head.Val == val { return head.Next }
    curr := head
    for curr.Next != nil && curr.Next.Val != val {
        curr = curr.Next
    }
    if curr.Next != nil {
        curr.Next = curr.Next.Next // Unlink
    }
    return head
}`,
                java: `public Node delete(Node head, int val) {
    if (head == null) return null;
    if (head.val == val) return head.next;
    Node curr = head;
    while (curr.next != null && curr.next.val != val) {
        curr = curr.next;
    }
    if (curr.next != null) {
        curr.next = curr.next.next;
    }
    return head;
}`,
                python: `def delete(head, val):
    if not head: return None
    if head.val == val: return head.next
    curr = head
    while curr.next and curr.next.val != val:
        curr = curr.next
    if curr.next:
        curr.next = curr.next.next
    return head`
            }
        };
        
        const CODES_DLL = {
            insertHead: {
                go: `func insertHead(head *Node, val int) *Node {
    newNode := &Node{Val: val}
    if head != nil {
        head.Prev = newNode
        newNode.Next = head
    }
    return newNode
}`,
                java: `public Node insertHead(Node head, int val) {
    Node newNode = new Node(val);
    if (head != null) {
        head.prev = newNode;
        newNode.next = head;
    }
    return newNode;
}`,
                python: `def insert_head(head, val):
    new_node = Node(val)
    if head:
        head.prev = new_node
        new_node.next = head
    return new_node`
            },
            insertTail: {
                go: `func insertTail(head *Node, val int) *Node {
    newNode := &Node{Val: val}
    if head == nil { return newNode }
    curr := head
    for curr.Next != nil { curr = curr.Next }
    curr.Next = newNode
    newNode.Prev = curr
    return head
}`,
                java: `public Node insertTail(Node head, int val) {
    Node newNode = new Node(val);
    if (head == null) return newNode;
    Node curr = head;
    while (curr.next != null) curr = curr.next;
    curr.next = newNode;
    newNode.prev = curr;
    return head;
}`,
                python: `def insert_tail(head, val):
    new_node = Node(val)
    if not head: return new_node
    curr = head
    while curr.next: curr = curr.next
    curr.next = new_node
    new_node.prev = curr
    return head`
            },
            delete: {
                go: `func delete(head *Node, val int) *Node {
    if head == nil { return nil }
    if head.Val == val {
        if head.Next != nil { head.Next.Prev = nil }
        return head.Next
    }
    curr := head
    for curr != nil && curr.Val != val { curr = curr.Next }
    if curr != nil {
        if curr.Next != nil { curr.Next.Prev = curr.Prev }
        if curr.Prev != nil { curr.Prev.Next = curr.Next }
    }
    return head
}`,
                java: `public Node delete(Node head, int val) {
    if (head == null) return null;
    if (head.val == val) {
        if (head.next != null) head.next.prev = null;
        return head.next;
    }
    Node curr = head;
    while (curr != null && curr.val != val) curr = curr.next;
    if (curr != null) {
        if (curr.next != null) curr.next.prev = curr.prev;
        if (curr.prev != null) curr.prev.next = curr.next;
    }
    return head;
}`,
                python: `def delete(head, val):
    if not head: return None
    if head.val == val:
        if head.next: head.next.prev = None
        return head.next
    curr = head
    while curr and curr.val != val: curr = curr.next
    if curr:
        if curr.next: curr.next.prev = curr.prev
        if curr.prev: curr.prev.next = curr.next
    return head`
            },
            search: CODES.search, // Same logic
            reverse: {
                go: `func reverse(head *Node) *Node {
    var temp *Node
    curr := head
    for curr != nil {
        temp = curr.Prev
        curr.Prev = curr.Next
        curr.Next = temp
        curr = curr.Prev
    }
    if temp != nil { head = temp.Prev }
    return head
}`,
                java: `public Node reverse(Node head) {
    Node temp = null; Node curr = head;
    while (curr != null) {
        temp = curr.prev; curr.prev = curr.next;
        curr.next = temp; curr = curr.prev;
    }
    if (temp != null) head = temp.prev;
    return head;
}`,
                python: `def reverse(head):
    temp = None; curr = head
    while curr:
        temp = curr.prev; curr.prev = curr.next
        curr.next = temp; curr = curr.prev
    if temp: head = temp.prev
    return head`
            }
        };

        // Initialize
        initMemory();
        renderCode('insertHead');
        render();
        initDragScroll();

        function toggleDLL() {
            isDLL = document.getElementById('dll-toggle').checked;
            resetList();
            statusText.textContent = isDLL ? "Switched to Doubly Linked List mode." : "Switched to Singly Linked List mode.";
            renderCode('insertHead');
        }

        function initMemory() {
            memoryView.innerHTML = '';
            for(let i=0; i<MEMORY_SIZE; i++) {
                const addr = `0x${(1000 + i * 8).toString(16).toUpperCase()}`;
                const block = document.createElement('div');
                block.className = 'memory-block';
                block.id = `mem-${i}`;
                block.innerHTML = `<span class="memory-addr">${addr}</span><span class="memory-val"></span><span class="memory-next"></span>`;
                memoryView.appendChild(block);
            }
        }

        function renderCode(op) {
            currentOp = op;
            const codeSet = isDLL ? CODES_DLL : CODES;
            const code = codeSet[op][currentLang];
            codeDisplay.innerHTML = '';
            
            const lines = code.split('\n');
            lines.forEach((line, i) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.id = `line-${i+1}`;
                let html = line
                    .replace(/\b(func|var|return|if|else|for|while|def|class|public|void|int|Node|new|null|nil|None)\b/g, '<span class="kwd">$1</span>')
                    .replace(/\/\/.*/g, '<span class="com">$&</span>')
                    .replace(/#.*/g, '<span class="com">$&</span>');
                div.innerHTML = `<span class="ln">${i+1}</span>${html}`;
                codeDisplay.appendChild(div);
            });
        }

        function highlightLine(num) {
            document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
            const line = document.getElementById(`line-${num}`);
            if (line) line.classList.add('active');
        }

        function copyCode() {
            const codeSet = isDLL ? CODES_DLL : CODES;
            const code = codeSet[currentOp][currentLang];
            navigator.clipboard.writeText(code);
        }

        function allocateNode(val) {
            const emptyIndices = memorySlots.map((v, i) => v === null ? i : -1).filter(i => i !== -1);
            if (emptyIndices.length === 0) {
                statusText.textContent = "Memory Full! Cannot allocate new node.";
                return null;
            }
            const idx = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
            const addr = `0x${(1000 + idx * 8).toString(16).toUpperCase()}`;
            
            const node = {
                val: val,
                next: null,
                prev: null,
                addr: addr,
                memIdx: idx
            };
            memorySlots[idx] = node;
            return node;
        }

        function freeNode(node) {
            if(node && node.memIdx !== undefined) {
                memorySlots[node.memIdx] = null;
            }
        }

        async function insertHead() {
            if (isAnimating) return;
            const val = parseInt(input.value);
            if (isNaN(val)) return;
            
            isAnimating = true;
            renderCode('insertHead');
            highlightLine(1);
            await sleep(300);

            statusText.textContent = `Allocating new node with value ${val}...`;
            highlightLine(2);

            const newNode = allocateNode(val);
            if (!newNode) { isAnimating = false; return; }
            
            render();
            highlightMemory(newNode.memIdx);
            await sleep(800);
            
            if (isDLL) {
                highlightLine(3);
                if (head) {
                    highlightLine(4);
                    highlightLine(5);
                }
            } else {
                highlightLine(3);
            }

            newNode.next = head;
            if (isDLL && head) head.prev = newNode;
            head = newNode;
            
            statusText.textContent = `Node allocated at ${newNode.addr}. Pointing to old head.`;
            render();
            await sleep(500);
            
            highlightLine(isDLL ? 7 : 4);
            unhighlightMemory();
            isAnimating = false;
        }

        async function insertTail() {
            if (isAnimating) return;
            const val = parseInt(input.value);
            if (isNaN(val)) return;

            isAnimating = true;
            renderCode('insertTail');
            highlightLine(1);
            await sleep(300);
            
            highlightLine(2);
            const newNode = allocateNode(val);
            if (!newNode) { isAnimating = false; return; }
            
            render();
            highlightMemory(newNode.memIdx);
            statusText.textContent = `Allocated node at ${newNode.addr}. Traversing to tail...`;
            await sleep(800);

            highlightLine(3);
            if (!head) {
                head = newNode;
                render();
                statusText.textContent = "List was empty. New node is head.";
                unhighlightMemory();
                isAnimating = false;
                return;
            } else {
                highlightLine(4);
                let curr = head;
                
                if (isDLL) highlightLine(5); else highlightLine(5);
                while (curr.next) {
                    if (!isDLL) highlightLine(6);
                    highlightNode(curr);
                    await sleep(400);
                    curr = curr.next;
                    if (isDLL) highlightLine(5); else highlightLine(5);
                }
                highlightNode(curr);
                await sleep(400);
                
                if (isDLL) { highlightLine(6); highlightLine(7); } else { highlightLine(8); }
                curr.next = newNode;
                if (isDLL) newNode.prev = curr;
            }
            
            render();
            statusText.textContent = "Linked new node to tail.";
            highlightLine(isDLL ? 8 : 9);
            unhighlightMemory();
            isAnimating = false;
        }

        async function deleteNode() {
            if (isAnimating || !head) return;
            const val = parseInt(input.value);
            if (isNaN(val)) return;

            isAnimating = true;
            renderCode('delete');
            highlightLine(1);
            await sleep(300);

            statusText.textContent = `Searching for value ${val} to delete...`;

            highlightLine(2);
            if (!head) { isAnimating = false; return; }

            highlightLine(3);
            if (head.val === val) {
                if (isDLL) highlightLine(4);
                const toDelete = head;
                head = head.next;
                if (isDLL && head) head.prev = null;
                freeNode(toDelete);
                render();
                statusText.textContent = `Deleted head node. Memory freed.`;
                highlightLine(isDLL ? 5 : 3);
                isAnimating = false;
                return;
            }

            if (isDLL) {
                // DLL Logic (Find node itself)
                highlightLine(7);
                let curr = head;
                
                highlightLine(8);
                while (curr != null && curr.val !== val) {
                    highlightNode(curr);
                    await sleep(400);
                    curr = curr.next;
                    highlightLine(8);
                }

                highlightLine(9);
                if (curr != null) {
                    highlightNode(curr);
                    statusText.textContent = `Found ${val} at ${curr.addr}. Unlinking...`;
                    await sleep(800);

                    highlightLine(10);
                    if (curr.next != null) curr.next.prev = curr.prev;
                    highlightLine(11);
                    if (curr.prev != null) curr.prev.next = curr.next;
                    
                    freeNode(curr);
                    render();
                    statusText.textContent = "Node deleted and memory freed.";
                } else {
                    statusText.textContent = "Value not found.";
                }
                highlightLine(13);
            } else {
                // SLL Logic (Find prev node)
                highlightLine(4);
                let curr = head;
                highlightLine(5);
                while (curr.next && curr.next.val !== val) {
                    highlightLine(6);
                    highlightNode(curr);
                    await sleep(400);
                    curr = curr.next;
                    highlightLine(5);
                }

                highlightLine(8);
                if (curr.next) {
                    highlightLine(9);
                    const toDelete = curr.next;
                    highlightNode(toDelete);
                    statusText.textContent = `Found ${val} at ${toDelete.addr}. Unlinking...`;
                    await sleep(800);
                    
                    curr.next = curr.next.next;
                    freeNode(toDelete);
                    render();
                    statusText.textContent = "Node deleted and memory freed.";
                } else {
                    statusText.textContent = "Value not found.";
                }
                highlightLine(11);
            }
            
            isAnimating = false;
        }

        function resetList() {
            if (isAnimating) return;
            head = null;
            for(let i=0; i<MEMORY_SIZE; i++) memorySlots[i] = null;
            render();
            statusText.textContent = "List reset. Memory cleared.";
        }

        function render() {
            // Render Memory View
            for(let i=0; i<MEMORY_SIZE; i++) {
                const block = document.getElementById(`mem-${i}`);
                const data = memorySlots[i];
                if (data) {
                    block.classList.add('occupied');
                    block.querySelector('.memory-val').textContent = data.val;
                    block.querySelector('.memory-next').textContent = data.next ? `‚Üí ${data.next.addr}` : '‚Üí null';
                } else {
                    block.classList.remove('occupied', 'highlight');
                    block.querySelector('.memory-val').textContent = '';
                    block.querySelector('.memory-next').textContent = '';
                }
            }

            // Render Logical View (SVG)
            svg.innerHTML = '';
            if (!head) {
                svg.style.width = '100%';
                return;
            }

            let curr = head;
            let prevNode = null;
            let x = 50;
            const y = 100;
            const gap = 100;

            // Arrow Marker
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            defs.innerHTML = `<marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" /></marker>`;
            svg.appendChild(defs);

            while (curr) {
                // Draw Node
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("id", `node-${curr.memIdx}`);
                
                // Rect
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x);
                rect.setAttribute("y", y - 20);
                rect.setAttribute("width", 60);
                rect.setAttribute("height", 40);
                rect.setAttribute("rx", 5);
                rect.setAttribute("class", "node-rect");
                g.appendChild(rect);

                // Value
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x + 30);
                text.setAttribute("y", y);
                text.setAttribute("class", "node-text");
                text.textContent = curr.val;
                g.appendChild(text);

                // Address Label
                const addrText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                addrText.setAttribute("x", x + 30);
                addrText.setAttribute("y", y + 35);
                addrText.setAttribute("class", "ptr-text");
                addrText.textContent = curr.addr;
                g.appendChild(addrText);

                svg.appendChild(g);

                // Draw Arrow
                if (curr.next) {
                    const yOffset = isDLL ? -8 : 0;
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", x + 60);
                    line.setAttribute("y1", y + yOffset);
                    line.setAttribute("x2", x + gap);
                    line.setAttribute("y2", y + yOffset);
                    line.setAttribute("stroke", "#94a3b8");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("marker-end", "url(#arrow)");
                    svg.appendChild(line);
                }

                if (isDLL && curr.prev === prevNode && prevNode !== null) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", x);
                    line.setAttribute("y1", y + 8);
                    line.setAttribute("x2", x - gap + 60);
                    line.setAttribute("y2", y + 8);
                    line.setAttribute("stroke", "#facc15");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("marker-end", "url(#arrow)");
                    svg.appendChild(line);
                }

                prevNode = curr;
                curr = curr.next;
                x += gap;
            }
            
            // Update SVG width to allow scrolling
            const requiredWidth = Math.max(logicalContainer.clientWidth, x + 50);
            svg.style.width = `${requiredWidth}px`;
        }

        function highlightMemory(idx) {
            document.getElementById(`mem-${idx}`)?.classList.add('highlight');
        }

        function unhighlightMemory() {
            document.querySelectorAll('.memory-block').forEach(b => b.classList.remove('highlight'));
        }

        function highlightNode(node) {
            const g = document.getElementById(`node-${node.memIdx}`);
            if (g) {
                g.querySelector('rect').style.stroke = '#facc15';
                setTimeout(() => g.querySelector('rect').style.stroke = '', 400);
            }
        }

        function switchLang(lang) {
            currentLang = lang;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            renderCode('insertHead'); // Default
        }

        function initDragScroll() {
            let isDown = false;
            let startX;
            let scrollLeft;

            logicalContainer.addEventListener('mousedown', (e) => {
                isDown = true;
                logicalContainer.classList.add('active');
                startX = e.pageX - logicalContainer.offsetLeft;
                scrollLeft = logicalContainer.scrollLeft;
            });

            logicalContainer.addEventListener('mouseleave', () => {
                isDown = false;
                logicalContainer.classList.remove('active');
            });

            logicalContainer.addEventListener('mouseup', () => {
                isDown = false;
                logicalContainer.classList.remove('active');
            });

            logicalContainer.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - logicalContainer.offsetLeft;
                const walk = (x - startX) * 1.5; // Scroll speed multiplier
                logicalContainer.scrollLeft = scrollLeft - walk;
            });
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    </script>
</body>
</html>