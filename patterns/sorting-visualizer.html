<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Visualizer - Software Systems Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <style>
        /* Tracker Layout */
        .viz-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            overflow-y: auto;
            padding-right: 5px;
        }

        .tracker {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .tracker-header {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 4px 10px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
        }

        .tracker-content {
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 120px;
            position: relative;
            overflow-x: auto;
        }

        #chart-tracker {
            height: 180px; /* Explicit height required for percentage bars */
        }

        /* Chart Tracker (Histogram) */
        .chart-bar {
            width: 20px;
            margin: 0 2px;
            background-color: #cbd5e1; /* Light gray default */
            transition: height 0.2s, background-color 0.2s;
            border-radius: 2px 2px 0 0;
            min-height: 4px;
        }
        .chart-bar.active { background-color: var(--accent-color); }
        .chart-bar.compare { background-color: #fb923c; }
        .chart-bar.sorted { background-color: #22c55e; }

        /* Array Tracker (Cells) */
        .array-row {
            display: flex;
            gap: 4px;
        }
        .array-cell {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            position: relative;
            background-color: var(--bg-primary);
            transition: all 0.2s;
        }
        .array-cell .idx-label {
            position: absolute;
            bottom: -18px;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        .array-cell.active { background-color: rgba(59, 130, 246, 0.2); border-color: var(--accent-color); }
        .array-cell.compare { background-color: rgba(251, 146, 60, 0.2); border-color: #fb923c; }
        .array-cell.sorted { background-color: rgba(34, 197, 94, 0.2); border-color: #22c55e; }

        /* Aux Tracker (Buckets) */
        .buckets-container {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            height: 100%;
            margin: 0 auto;
        }
        .bucket {
            display: flex;
            flex-direction: column-reverse; /* Stack from bottom */
            width: 40px;
            min-height: 100px;
            border: 1px solid var(--border-color);
            border-top: none;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.02));
            position: relative;
            padding: 2px;
            gap: 2px;
        }
        .bucket-label {
            position: absolute;
            bottom: -20px;
            width: 100%;
            text-align: center;
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .bucket-item {
            width: 100%;
            height: 30px;
            background-color: var(--accent-color);
            color: #000;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 2px;
            animation: dropIn 0.3s ease-out;
        }
        @keyframes dropIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Log Panel */
        .log-section {
            height: 150px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 0;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            max-height: 400px;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
        .log-entry.highlight { color: var(--accent-color); }

        /* Explanation Panel */
        .explanation-panel {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 3px solid var(--accent-color);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        /* Controls in Code Panel */
        .code-controls {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background-color: rgba(255,255,255,0.02);
        }
        
        .control-group-inline {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .code-line { white-space: pre; }
        .kwd { color: #f472b6; font-weight: bold; }
        .typ { color: #60a5fa; }
        .num { color: #facc15; }
        .com { color: #6a9955; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë Software Systems</h1>
                <p>Sorting Visualizer</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Back</div>
                <a href="../index.html" class="nav-item">‚Üê Dashboard</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Algorithms</div>
                <a href="javascript:void(0)" class="nav-item active" id="nav-bubble" onclick="selectAlgo('bubble')">Bubble Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-selection" onclick="selectAlgo('selection')">Selection Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-insertion" onclick="selectAlgo('insertion')">Insertion Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-merge" onclick="selectAlgo('merge')">Merge Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-quick" onclick="selectAlgo('quick')">Quick Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-heap" onclick="selectAlgo('heap')">Heap Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-counting" onclick="selectAlgo('counting')">Counting Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-radix" onclick="selectAlgo('radix')">Radix Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-bucket" onclick="selectAlgo('bucket')">Bucket Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-shell" onclick="selectAlgo('shell')">Shell Sort</a>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar">
                    <div id="status-text" style="font-family: monospace; color: var(--accent-color);">Ready.</div>
                    <div id="step-counter" style="font-family: monospace; color: var(--text-secondary); margin-left: auto;">Step 0 / 0</div>
                </div>
                
                <div class="split-view">
                    <!-- Visualization Trackers -->
                    <div class="canvas-section">
                        <div class="viz-container">
                            <div class="tracker">
                                <div class="tracker-header">Chart (Distribution)</div>
                                <div class="tracker-content" id="chart-tracker"></div>
                            </div>
                            <div class="tracker">
                                <div class="tracker-header">Array (Values)</div>
                                <div class="tracker-content" id="array-tracker"></div>
                            </div>
                            <!-- Log Panel -->
                            <div class="log-section" id="log-panel">
                                <div class="log-entry">Ready to start...</div>
                            </div>
                            <div class="tracker" id="aux-tracker-wrapper" style="display: none;">
                                <div class="tracker-header">Auxiliary (Buckets / Temp)</div>
                                <div class="tracker-content" id="aux-tracker"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Code Panel -->
                    <div class="code-section">
                        <div class="code-header">
                            <span>Algorithm Code</span>
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go')">Go</button>
                                <button class="tab-btn" onclick="switchLang('java')">Java</button>
                                <button class="tab-btn" onclick="switchLang('python')">Python</button>
                            </div>
                        </div>

                        <div id="code-display" class="algo-code active">
                            <!-- Code will be injected here by JS -->
                        </div>
                        
                        <div class="code-controls">
                            <div class="control-group-inline">
                                <input type="range" id="speedRange" min="50" max="1000" step="50" value="400" onchange="setSpeed(this.value)" title="Speed">
                                <button class="action-btn" onclick="stepBackward()">‚èÆ</button>
                                <button class="action-btn" id="playBtn" onclick="togglePlay()">‚ñ∂ Play</button>
                                <button class="action-btn" onclick="stepForward()">‚è≠</button>
                                <button class="action-btn warning" onclick="reset()">‚Ü∫ Reset</button>
                            </div>
                        </div>
                        <div class="explanation-panel" id="explanation">
                            Algorithm explanation will appear here.
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Configuration
        let ANIMATION_SPEED = 400;
        let array = [15, 8, 20, 5, 12, 3, 10, 18];
        // For bucket sort, we might normalize or use specific values
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let intervalId = null;
        let currentLang = 'go';
        let currentAlgo = 'bubble';

        const LINES = {
            bubble: {
                compare: { go: 4, java: 4, python: 4 },
                swap: { go: 5, java: 5, python: 5 },
                sorted: { go: 2, java: 2, python: 2 }
            },
            selection: {
                select: { go: 3, java: 3, python: 3 },
                compare: { go: 5, java: 5, python: 5 },
                newMin: { go: 5, java: 5, python: 5 },
                swap: { go: 7, java: 7, python: 6 }
            },
            insertion: {
                select: { go: 3, java: 3, python: 3 },
                compare: { go: 4, java: 4, python: 4 },
                shift: { go: 5, java: 5, python: 5 },
                insert: { go: 7, java: 7, python: 6 }
            },
            merge: {
                split: { go: 3, java: 3, python: 3 },
                mergeStart: { go: 9, java: 9, python: 8 },
                compare: { go: 12, java: 12, python: 11 },
                overwrite: { go: 13, java: 13, python: 12 }
            },
            quick: {
                pivot: { go: 10, java: 10, python: 9 },
                compare: { go: 13, java: 13, python: 12 },
                swap: { go: 15, java: 15, python: 14 },
                placePivot: { go: 18, java: 18, python: 16 }
            },
            heap: {
                heapify: { go: 12, java: 12, python: 11 },
                compare: { go: 15, java: 15, python: 14 },
                swap: { go: 18, java: 18, python: 17 },
                extract: { go: 8, java: 8, python: 7 }
            },
            counting: {
                count: { go: 4, java: 4, python: 4 },
                place: { go: 8, java: 8, python: 8 }
            },
            radix: {
                digit: { go: 3, java: 3, python: 3 },
                update: { go: 13, java: 13, python: 11 }
            },
            bucket: {
                distribute: { go: 4, java: 5, python: 4 },
                sortBucket: { go: 8, java: 9, python: 7 },
                collect: { go: 10, java: 11, python: 9 }
            },
            shell: {
                gap: { go: 3, java: 3, python: 3 },
                compare: { go: 7, java: 7, python: 7 },
                shift: { go: 8, java: 8, python: 8 },
                place: { go: 10, java: 10, python: 9 }
            }
        };

        // Code Data Store
        const ALGO_CODES = {
            bubble: {
                go: `func bubbleSort(arr []int) {
  for i := 0; i < len(arr); i++ { // Outer loop for passes
    for j := 0; j < len(arr)-i-1; j++ { // Inner loop for comparison
      if arr[j] > arr[j+1] { // Compare adjacent elements
        arr[j], arr[j+1] = arr[j+1], arr[j] // Swap if wrong order
      }
    }
  }
}`,
                java: `void bubbleSort(int[] arr) {
  for (int i = 0; i < arr.length; i++) { // Outer loop
    for (int j = 0; j < arr.length - i - 1; j++) { // Inner loop
      if (arr[j] > arr[j+1]) { // Compare adjacent
        swap(arr, j, j+1); // Swap if needed
      }
    }
  }
}`,
                python: `def bubble_sort(arr):
  for i in range(len(arr)): # Traverse all elements
    for j in range(len(arr) - i - 1): # Last i elements are sorted
      if arr[j] > arr[j+1]: # Compare adjacent
        arr[j], arr[j+1] = arr[j+1], arr[j] # Swap`
            },
            selection: {
                go: `func selectionSort(arr []int) {
  for i := 0; i < len(arr); i++ { // Iterate through array
    minIdx := i // Assume current is min
    for j := i + 1; j < len(arr); j++ { // Find min in unsorted
      if arr[j] < arr[minIdx] { minIdx = j } // Update min index
    }
    arr[i], arr[minIdx] = arr[minIdx], arr[i] // Swap min to correct pos
  }
}`,
                java: `void selectionSort(int[] arr) {
  for (int i = 0; i < arr.length; i++) { // Iterate array
    int minIdx = i; // Assume i is min
    for (int j = i + 1; j < arr.length; j++) { // Find actual min
      if (arr[j] < arr[minIdx]) minIdx = j; // Update min index
    }
    swap(arr, i, minIdx); // Swap min to position i
  }
}`,
                python: `def selection_sort(arr):
  for i in range(len(arr)): # Traverse array
    min_idx = i # Assume current is min
    for j in range(i + 1, len(arr)): # Find min in rest
      if arr[j] < arr[min_idx]: min_idx = j # Update min index
    arr[i], arr[min_idx] = arr[min_idx], arr[i] # Swap`
            },
            insertion: {
                go: `func insertionSort(arr []int) {
  for i := 1; i < len(arr); i++ { // Start from second element
    key := arr[i]; j := i - 1 // Element to insert
    for j >= 0 && arr[j] > key { // Shift larger elements
      arr[j+1] = arr[j]; j-- // Move right
    } 
    arr[j+1] = key // Insert key
  }
}`,
                java: `void insertionSort(int[] arr) {
  for (int i = 1; i < arr.length; i++) { // Iterate from 2nd element
    int key = arr[i]; int j = i - 1; // Key to insert
    while (j >= 0 && arr[j] > key) { // Shift elements > key
      arr[j+1] = arr[j]; j--; // Move right
    }
    arr[j+1] = key; // Place key
  }
}`,
                python: `def insertion_sort(arr):
  for i in range(1, len(arr)): # Start from 2nd element
    key = arr[i]; j = i - 1 # Element to insert
    while j >= 0 and arr[j] > key: # Shift larger elements
      arr[j+1] = arr[j]; j -= 1 # Move right
    arr[j+1] = key # Insert key`
            },
            merge: {
                go: `func mergeSort(arr []int) []int {
  if len(arr) <= 1 { return arr } // Base case
  mid := len(arr) / 2 // Find middle
  left := mergeSort(arr[:mid]) // Sort left
  right := mergeSort(arr[mid:]) // Sort right
  return merge(left, right) // Merge sorted halves
}
func merge(left, right []int) []int {
  res := []int{}; i, j := 0, 0
  for i < len(left) && j < len(right) { // Compare elements
    if left[i] <= right[j] {
      res = append(res, left[i]); i++ // Take from left
    } else {
      res = append(res, right[j]); j++ // Take from right
    }
  }
  res = append(res, left[i:]...) // Append remaining
  res = append(res, right[j:]...)
  return res
}`, // Simplified for display
                java: `void mergeSort(int[] arr, int l, int r) {
  if (l < r) { // Base case check
    int m = (l + r) / 2; // Find middle
    mergeSort(arr, l, m); // Sort left
    mergeSort(arr, m + 1, r); // Sort right
    merge(arr, l, m, r); // Merge halves
  }
}
void merge(int[] arr, int l, int m, int r) {
  // Copy data to temp arrays L[] and R[]
  int i = 0, j = 0; // Initial indexes
  int k = l; // Initial index of merged
  while (i < n1 && j < n2) { // Merge temp arrays
    if (L[i] <= R[j]) {
      arr[k] = L[i]; i++; // Take from L
    } else {
      arr[k] = R[j]; j++; // Take from R
    }
    k++;
  }
}`, // Simplified
                python: `def merge_sort(arr):
  if len(arr) > 1: # Base case
    mid = len(arr) // 2 # Find middle
    L = arr[:mid]; R = arr[mid:] # Split
    merge_sort(L); merge_sort(R) # Recursive sort
    
    i = j = k = 0
    while i < len(L) and j < len(R): # Merge
      if L[i] < R[j]:
        arr[k] = L[i]; i += 1 # Take from L
      else:
        arr[k] = R[j]; j += 1 # Take from R
      k += 1`
            },
            quick: {
                go: `func quickSort(arr []int, low, high int) {
  if low < high { // Base case
    p := partition(arr, low, high) // Partition index
    quickSort(arr, low, p-1) // Sort left
    quickSort(arr, p+1, high) // Sort right
  }
}
func partition(arr []int, low, high int) int {
  pivot := arr[high]; i := low // Pivot is last element
  for j := low; j < high; j++ { // Iterate
    if arr[j] < pivot { // If smaller than pivot
      arr[i], arr[j] = arr[j], arr[i]; i++ // Swap
    }
  }
  arr[i], arr[high] = arr[high], arr[i] // Place pivot
  return i
}`,
                java: `void quickSort(int[] arr, int low, int high) {
  if (low < high) { // Base case
    int pi = partition(arr, low, high); // Partitioning index
    quickSort(arr, low, pi - 1); // Sort elements before
    quickSort(arr, pi + 1, high); // Sort elements after
  }
}
int partition(int[] arr, int low, int high) {
  int pivot = arr[high]; // Pivot
  int i = (low - 1); // Index of smaller element
  for (int j = low; j < high; j++) {
    if (arr[j] < pivot) { // If current < pivot
      i++;
      int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; // Swap
    }
  }
  int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; // Swap pivot
  return i + 1;
}`,
                python: `def quick_sort(arr, low, high):
  if low < high: # Base case
    pi = partition(arr, low, high) # Partition index
    quick_sort(arr, low, pi - 1) # Sort left
    quick_sort(arr, pi + 1, high) # Sort right

def partition(arr, low, high):
  pivot = arr[high]; i = low - 1 # Pivot
  for j in range(low, high):
    if arr[j] < pivot: # If smaller than pivot
      i += 1; arr[i], arr[j] = arr[j], arr[i] # Swap
  arr[i + 1], arr[high] = arr[high], arr[i + 1] # Place pivot
  return i + 1`
            },
            heap: {
                go: `func heapSort(arr []int) {
  n := len(arr)
  for i := n/2 - 1; i >= 0; i-- { // Build heap
    heapify(arr, n, i)
  }
  for i := n - 1; i > 0; i-- { // Extract elements
    arr[0], arr[i] = arr[i], arr[0] // Move root to end
    heapify(arr, i, 0) // Max heapify reduced heap
  } 
}
func heapify(arr []int, n, i int) {
  largest := i // Initialize largest as root
  l, r := 2*i+1, 2*i+2 // Left and right children
  if l < n && arr[l] > arr[largest] { largest = l } // Check left
  if r < n && arr[r] > arr[largest] { largest = r } // Check right
  if largest != i { // If largest is not root
    arr[i], arr[largest] = arr[largest], arr[i] // Swap
    heapify(arr, n, largest) // Recursively heapify
  }
}`,
                java: `void heapSort(int[] arr) {
  int n = arr.length;
  for (int i = n / 2 - 1; i >= 0; i--) // Build heap
    heapify(arr, n, i);
  for (int i = n - 1; i > 0; i--) { // Extract elements
    swap(arr, 0, i); // Move current root to end
    heapify(arr, i, 0); // Call max heapify
  }
}
void heapify(int[] arr, int n, int i) {
  int largest = i; // Initialize largest as root
  int l = 2 * i + 1; // Left child
  int r = 2 * i + 2; // Right child
  if (l < n && arr[l] > arr[largest]) largest = l; // Check left
  if (r < n && arr[r] > arr[largest]) largest = r; // Check right
  if (largest != i) { // If largest is not root
    swap(arr, i, largest); // Swap
    heapify(arr, n, largest); // Recursively heapify
  }
}`,
                python: `def heap_sort(arr):
  n = len(arr)
  for i in range(n // 2 - 1, -1, -1): # Build maxheap
    heapify(arr, n, i)
  for i in range(n - 1, 0, -1): # Extract elements
    arr[i], arr[0] = arr[0], arr[i] # Swap
    heapify(arr, i, 0) # Heapify root

def heapify(arr, n, i):
  largest = i # Initialize largest as root
  l, r = 2 * i + 1, 2 * i + 2 # Children
  if l < n and arr[l] > arr[largest]: largest = l # Check left
  if r < n and arr[r] > arr[largest]: largest = r # Check right
  if largest != i: # If root not largest
    arr[i], arr[largest] = arr[largest], arr[i] # Swap
    heapify(arr, n, largest) # Recursively heapify`
            },
            counting: {
                go: `func countingSort(arr []int) {
  max := findMax(arr) // Find max value
  count := make([]int, max+1) // Create count array
  for _, x := range arr { count[x]++ } // Count occurrences
  idx := 0
  for i, c := range count { // Iterate count array
    for c > 0 { 
      arr[idx] = i // Reconstruct array
      idx++; c--
    }
  }
}`,
                java: `void countingSort(int[] arr) {
  int max = findMax(arr); // Find max
  int[] count = new int[max + 1]; // Count array
  for (int x : arr) count[x]++; // Store count
  int idx = 0;
  for (int i = 0; i <= max; i++) { // Iterate counts
    while (count[i] > 0) {
      arr[idx++] = i; // Place elements
      count[i]--;
    }
  }
}`,
                python: `def counting_sort(arr):
  max_val = max(arr) # Find max
  count = [0] * (max_val + 1) # Count array
  for x in arr: count[x] += 1 # Store count
  idx = 0
  for i in range(len(count)): # Reconstruct
    while count[i] > 0:
      arr[idx] = i
      idx += 1; count[i] -= 1`
            },
            radix: {
                go: `func radixSort(arr []int) {
  max := getMax(arr) // Find max number
  for exp := 1; max/exp > 0; exp *= 10 { // For each digit
    // Counting sort by digit
    count := make([]int, 10)
    for i := 0; i < len(arr); i++ {
      count[(arr[i]/exp)%10]++ // Count digits
    }
    // ... (prefix sum logic)
    // Build output array
    for i := 0; i < len(arr); i++ {
      arr[i] = output[i] // Copy back
    }
  }
}`,
                java: `void radixSort(int[] arr) {
  int max = getMax(arr); // Find max
  for (int exp = 1; max/exp > 0; exp *= 10) { // Exponent
    // Count sort by digit
    int[] count = new int[10];
    for (int i = 0; i < n; i++)
      count[(arr[i] / exp) % 10]++; // Count occurrences
    // ...
    for (int i = 0; i < n; i++)
      arr[i] = output[i]; // Copy output
  }
}`,
                python: `def radix_sort(arr):
  max_val = max(arr) # Find max
  exp = 1
  while max_val // exp > 0: # For each digit
    # Counting sort by digit
    count = [0] * 10
    for i in range(n):
      index = arr[i] // exp
      count[index % 10] += 1 # Count
    # ...
    for i in range(n):
      arr[i] = output[i] # Copy
    exp *= 10`
            },
            bucket: {
                go: `func bucketSort(arr []int) {
  buckets := make([][]int, len(arr)) // Create buckets
  for _, num := range arr {
    idx := (num * len(arr)) / (max + 1) // Calculate index
    buckets[idx] = append(buckets[idx], num) // Add to bucket
  }
  idx := 0
  for _, bucket := range buckets {
    sort.Ints(bucket) // Sort individual bucket
    for _, num := range bucket {
      arr[idx] = num; idx++ // Concatenate
    }
  }
}`,
                java: `void bucketSort(float[] arr) {
  int n = arr.length;
  ArrayList[] buckets = new ArrayList[n]; // Create buckets
  for (int i=0; i<n; i++) buckets[i] = new ArrayList<>();
  for (float num : arr) {
    int idx = (int)num * n; // Index in bucket
    buckets[idx].add(num);
  }
  for (int i=0; i<n; i++) {
    Collections.sort(buckets[i]); // Sort bucket
    for (float num : buckets[i]) {
      arr[idx++] = num; // Concatenate
    }
  }
}`,
                python: `def bucket_sort(arr):
  buckets = [[] for _ in range(len(arr))] # Create buckets
  for num in arr:
    idx = int(num * len(arr)) # Index
    buckets[idx].append(num)
  idx = 0
  for bucket in buckets:
    bucket.sort() # Sort bucket
    for num in bucket:
      arr[idx] = num # Concatenate
      idx += 1`
            },
            shell: {
                go: `func shellSort(arr []int) {
  n := len(arr)
  for gap := n/2; gap > 0; gap /= 2 { // Reduce gap
    for i := gap; i < n; i++ { // Gapped insertion sort
      temp := arr[i]
      j := i
      for ; j >= gap && arr[j-gap] > temp; j -= gap {
        arr[j] = arr[j-gap] // Shift elements
      }
      arr[j] = temp // Place temp
    }
  }
}`,
                java: `void shellSort(int[] arr) {
  int n = arr.length;
  for (int gap = n/2; gap > 0; gap /= 2) { // Reduce gap
    for (int i = gap; i < n; i++) { // Insertion sort
      int temp = arr[i];
      int j;
      for (j = i; j >= gap && arr[j-gap] > temp; j -= gap) {
        arr[j] = arr[j-gap]; // Shift
      }
      arr[j] = temp; // Place
    }
  }
}`,
                python: `def shell_sort(arr):
  n = len(arr)
  gap = n // 2 # Start with large gap
  while gap > 0:
    for i in range(gap, n): # Gapped insertion sort
      temp = arr[i]
      j = i
      while j >= gap and arr[j-gap] > temp:
        arr[j] = arr[j-gap] # Shift
        j -= gap
      arr[j] = temp # Place
    gap //= 2 # Reduce gap`
            }
        };

        function init() {
            reset();
        }

        // Helper to create a standard step object
        function createStep(type, arr, msg, lines, extras = {}) {
            return { type, arr: [...arr], msg, lines, log: msg, ...extras };
        }

        function generateSteps(type) {
            steps = [];
            let arr = [...array];
            
            if (type === 'bubble') {
                for (let i = 0; i < arr.length; i++) {
                    for (let j = 0; j < arr.length - i - 1; j++) {
                        steps.push(createStep('COMPARE', arr, `Compare ${arr[j]} > ${arr[j+1]}?`, LINES.bubble.compare, { compare: [j, j+1] }));
                        if (arr[j] > arr[j+1]) {
                            [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
                            steps.push(createStep('SWAP', arr, 'Swap!', LINES.bubble.swap, { swap: [j, j+1] }));
                        }
                    }
                    steps.push(createStep('SORTED', arr, 'Element sorted', LINES.bubble.sorted, { sorted: Array.from({length: i+1}, (_, k) => arr.length-1-k) }));
                }
            } else if (type === 'selection') {
                for (let i = 0; i < arr.length; i++) {
                    let minIdx = i; 
                    steps.push(createStep('SELECT', arr, `Current min index: ${i}`, LINES.selection.select, { active: [i] }));
                    for (let j = i + 1; j < arr.length; j++) {
                        steps.push(createStep('COMPARE', arr, `Check ${arr[j]} < ${arr[minIdx]}?`, LINES.selection.compare, { active: [i], compare: [j, minIdx] }));
                        if (arr[j] < arr[minIdx]) {
                            minIdx = j;
                            steps.push(createStep('NEW_MIN', arr, `New min found: ${arr[minIdx]}`, LINES.selection.newMin, { active: [i], swap: [minIdx] }));
                        }
                    }
                    if (minIdx !== i) {
                        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                        steps.push(createStep('SWAP', arr, `Swap min ${arr[i]} to position ${i}`, LINES.selection.swap, { swap: [i, minIdx] }));
                    }
                }
            } else if (type === 'insertion') {
                for (let i = 1; i < arr.length; i++) {
                    let key = arr[i];
                    let j = i - 1;
                    steps.push(createStep('SELECT', arr, `Insert ${key}`, LINES.insertion.select, { active: [i] }));
                    while (j >= 0 && arr[j] > key) {
                        steps.push(createStep('COMPARE', arr, `${arr[j]} > ${key}, shift right`, LINES.insertion.compare, { compare: [j] }));
                        arr[j + 1] = arr[j];
                        j = j - 1;
                        steps.push(createStep('SHIFT', arr, 'Shifted', LINES.insertion.shift, { swap: [j+1] }));
                    }
                    arr[j + 1] = key;
                    steps.push(createStep('INSERT', arr, `Placed ${key}`, LINES.insertion.insert, { sorted: [j+1] }));
                }
            } else if (type === 'merge') {
                function mergeSortHelper(arr, start, end) {
                    if (start >= end) return;
                    const mid = Math.floor((start + end) / 2);
                    steps.push(createStep('SPLIT', arr, `Split at index ${mid}`, LINES.merge.split, { range: [start, end], active: [mid] }));
                    
                    mergeSortHelper(arr, start, mid);
                    mergeSortHelper(arr, mid + 1, end);
                    merge(arr, start, mid, end);
                }

                function merge(arr, start, mid, end) {
                    let left = arr.slice(start, mid + 1);
                    let right = arr.slice(mid + 1, end + 1);
                    let i = 0, j = 0, k = start;
                    
                    steps.push(createStep('MERGE_START', arr, `Merging range [${start}, ${end}]`, LINES.merge.mergeStart, { range: [start, end], active: Array.from({length: end-start+1}, (_, idx) => start+idx), aux: [left, right], auxLabels: ['Left', 'Right'] }));

                    while (i < left.length && j < right.length) {
                        steps.push(createStep('COMPARE', arr, `Compare ${left[i]} vs ${right[j]}`, LINES.merge.compare, { range: [start, end], compare: [start+i, mid+1+j], aux: [left, right], auxLabels: ['Left', 'Right'] }));
                        if (left[i] <= right[j]) {
                            arr[k] = left[i];
                            i++;
                        } else {
                            arr[k] = right[j];
                            j++;
                        }
                        steps.push(createStep('OVERWRITE', arr, `Placed ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k], aux: [left, right], auxLabels: ['Left', 'Right'] }));
                        k++;
                    }
                    while (i < left.length) {
                        arr[k] = left[i];
                        steps.push(createStep('OVERWRITE', arr, `Placed remaining ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k], aux: [left, right], auxLabels: ['Left', 'Right'] }));
                        i++; k++;
                    }
                    while (j < right.length) {
                        arr[k] = right[j];
                        steps.push(createStep('OVERWRITE', arr, `Placed remaining ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k], aux: [left, right], auxLabels: ['Left', 'Right'] }));
                        j++; k++;
                    }
                }
                mergeSortHelper(arr, 0, arr.length - 1);

            } else if (type === 'quick') {
                function quickSortHelper(arr, low, high) {
                    if (low < high) {
                        let pi = partition(arr, low, high);
                        quickSortHelper(arr, low, pi - 1);
                        quickSortHelper(arr, pi + 1, high);
                    }
                }

                function partition(arr, low, high) {
                    let pivot = arr[high];
                    let i = (low - 1);
                    steps.push(createStep('PIVOT', arr, `Pivot chosen: ${pivot}`, LINES.quick.pivot, { active: [high] }));

                    for (let j = low; j <= high - 1; j++) {
                        steps.push(createStep('COMPARE', arr, `Compare ${arr[j]} < ${pivot}?`, LINES.quick.compare, { compare: [j, high] }));
                        if (arr[j] < pivot) {
                            i++;
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            steps.push(createStep('SWAP', arr, `Swap ${arr[i]} and ${arr[j]}`, LINES.quick.swap, { swap: [i, j] }));
                        }
                    }
                    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                    steps.push(createStep('PLACE_PIVOT', arr, `Pivot placed at ${i+1}`, LINES.quick.placePivot, { swap: [i+1, high], sorted: [i+1] }));
                    return (i + 1);
                }
                quickSortHelper(arr, 0, arr.length - 1);
            } else if (type === 'heap') {
                function heapify(arr, n, i) {
                    let largest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;

                    if (l < n) {
                        steps.push({ type: 'COMPARE', arr: [...arr], compare: [l, largest], msg: `Compare left child ${arr[l]} > ${arr[largest]}?`, lines: LINES.heap.compare });
                        if (arr[l] > arr[largest]) largest = l;
                    }

                    if (r < n) {
                        steps.push({ type: 'COMPARE', arr: [...arr], compare: [r, largest], msg: `Compare right child ${arr[r]} > ${arr[largest]}?`, lines: LINES.heap.compare });
                        if (arr[r] > arr[largest]) largest = r;
                    }

                    if (largest !== i) {
                        [arr[i], arr[largest]] = [arr[largest], arr[i]];
                        steps.push({ type: 'SWAP', arr: [...arr], swap: [i, largest], msg: `Swap root ${arr[largest]} with largest child ${arr[i]}`, lines: LINES.heap.swap, log: `Heapify: Swapped index ${i} and ${largest}` });
                        heapify(arr, n, largest);
                    }
                }

                let n = arr.length;
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    steps.push({ type: 'HEAPIFY', arr: [...arr], active: [i], msg: `Building heap from index ${i}`, lines: LINES.heap.heapify });
                    heapify(arr, n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    [arr[0], arr[i]] = [arr[i], arr[0]];
                    steps.push({ type: 'EXTRACT', arr: [...arr], swap: [0, i], sorted: [i], msg: `Move max ${arr[i]} to end`, lines: LINES.heap.extract, log: `Extracted max ${arr[i]}` });
                    heapify(arr, i, 0);
                }
            } else if (type === 'counting') {
                let max = Math.max(...arr);
                let count = new Array(max + 1).fill(0);
                
                steps.push({ type: 'INIT', arr: [...arr], msg: `Find max value: ${max}`, lines: {go: 2, java: 2, python: 2} });
                
                for (let i = 0; i < arr.length; i++) {
                    count[arr[i]]++;
                    steps.push({ type: 'COUNT', arr: [...arr], active: [i], msg: `Count ${arr[i]}: ${count[arr[i]]}`, lines: LINES.counting.count, log: `Counting occurrence of ${arr[i]}` });
                }
                
                let idx = 0;
                for (let i = 0; i <= max; i++) {
                    while (count[i] > 0) {
                        arr[idx] = i;
                        steps.push({ type: 'PLACE', arr: [...arr], sorted: [idx], msg: `Place ${i} at index ${idx}`, lines: LINES.counting.place, log: `Placed ${i} at index ${idx}` });
                        idx++;
                        count[i]--;
                    }
                }
            } else if (type === 'radix') {
                let max = Math.max(...arr);
                for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                    steps.push({ type: 'DIGIT', arr: [...arr], msg: `Sorting by digit at ${exp}`, lines: LINES.radix.digit, log: `Processing digit position ${exp}` });
                    
                    let output = new Array(arr.length).fill(0);
                    let count = new Array(10).fill(0);
                    
                    for (let i = 0; i < arr.length; i++) {
                        count[Math.floor(arr[i] / exp) % 10]++;
                    }
                    for (let i = 1; i < 10; i++) {
                        count[i] += count[i - 1];
                    }
                    for (let i = arr.length - 1; i >= 0; i--) {
                        let digit = Math.floor(arr[i] / exp) % 10;
                        output[count[digit] - 1] = arr[i];
                        count[digit]--;
                    }
                    for (let i = 0; i < arr.length; i++) {
                        arr[i] = output[i];
                        steps.push({ type: 'UPDATE', arr: [...arr], active: [i], msg: `Update index ${i} with ${arr[i]}`, lines: LINES.radix.update, log: `Updated index ${i} to ${arr[i]}`, aux: buckets, auxLabels: auxLabels });
                    }
                }
            } else if (type === 'bucket') {
                // Normalize array to 0-1 range for visualization logic, but keep original values for display
                // For simplicity, let's assume input is scaled down or we use buckets based on max value
                let max = Math.max(...arr);
                let n = arr.length;
                // Use 5 buckets for visualization clarity
                let bucketCount = 5;
                let buckets = Array.from({length: bucketCount}, () => []);
                
                steps.push(createStep('INIT', arr, `Create ${bucketCount} buckets`, {go: 2, java: 3, python: 2}, { aux: JSON.parse(JSON.stringify(buckets)) }));
                
                for (let i = 0; i < n; i++) {
                    let idx = Math.floor((arr[i] / (max + 1)) * bucketCount);
                    buckets[idx].push(arr[i]);
                    steps.push(createStep('DISTRIBUTE', arr, `Place ${arr[i]} into bucket ${idx}`, LINES.bucket.distribute, { active: [i], aux: JSON.parse(JSON.stringify(buckets)), activeBucket: idx }));
                }
                
                let idx = 0;
                for (let i = 0; i < bucketCount; i++) {
                    if (buckets[i].length > 0) {
                        buckets[i].sort((a, b) => a - b);
                        steps.push(createStep('SORT_BUCKET', arr, `Sort bucket ${i}`, LINES.bucket.sortBucket, { aux: JSON.parse(JSON.stringify(buckets)), activeBucket: i }));
                        for (let val of buckets[i]) {
                            arr[idx] = val;
                            steps.push(createStep('COLLECT', arr, `Place ${val} back into array`, LINES.bucket.collect, { sorted: [idx], aux: JSON.parse(JSON.stringify(buckets)), activeBucket: i }));
                            idx++;
                        }
                    }
                }
            } else if (type === 'shell') {
                let n = arr.length;
                for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                    steps.push({ type: 'GAP', arr: [...arr], msg: `Gap size: ${gap}`, lines: LINES.shell.gap, log: `Gap set to ${gap}` });
                    
                    for (let i = gap; i < n; i++) {
                        let temp = arr[i];
                        let j;
                        steps.push({ type: 'INSERT_START', arr: [...arr], active: [i], msg: `Insert ${temp} into gap-sorted subarray`, lines: LINES.shell.gap });
                        for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                            steps.push({ type: 'COMPARE', arr: [...arr], compare: [j, j-gap], msg: `${arr[j-gap]} > ${temp}, shift right`, lines: LINES.shell.compare });
                            arr[j] = arr[j - gap];
                            steps.push({ type: 'SHIFT', arr: [...arr], swap: [j], msg: `Shifted ${arr[j]}`, lines: LINES.shell.shift, log: `Shifted ${arr[j]} right` });
                        }
                        arr[j] = temp;
                        steps.push({ type: 'PLACE', arr: [...arr], sorted: [j], msg: `Placed ${temp} at index ${j}`, lines: LINES.shell.place, log: `Placed ${temp} at ${j}` });
                    }
                }
            }
            
            steps.push({ type: 'DONE', arr: [...arr], sorted: arr.map((_, i) => i), msg: 'Sorted!', lines: {go: 99, java: 99, python: 99}, log: 'Sorting complete' });
        }

        function renderCode(algo, lang) {
            const codeContainer = document.getElementById('code-display');
            const code = ALGO_CODES[algo] && ALGO_CODES[algo][lang] ? ALGO_CODES[algo][lang] : "// Code not available";
            
            // Split into lines and wrap
            const lines = code.split('\n');
            let html = '';
            lines.forEach((line, i) => {
                let safeLine = line.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                let commentChar = lang === 'python' ? '#' : '//';
                let parts = safeLine.split(commentChar);
                let codePart = parts[0];
                let commentPart = parts.length > 1 ? commentChar + parts.slice(1).join(commentChar) : '';

                codePart = codePart
                    .replace(/\b(func|void|def|for|if|else|return|var|int|len|range|break|continue|class|public|private|static|while|new|import|package)\b/g, '<span class="kwd">$1</span>')
                    .replace(/\b(true|false|null|nil)\b/g, '<span class="typ">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="num">$1</span>');

                if (commentPart) commentPart = `<span class="com">${commentPart}</span>`;
                let formatted = codePart + commentPart;
                html += `<div class="code-line" id="${algo}-${lang}-${i+1}"><span class="ln">${i+1}</span>${formatted}</div>`;
            });
            codeContainer.innerHTML = html;
        }

        function render(stepIndex) {
            const state = steps[stepIndex];
            
            // 1. Render Chart (Histogram)
            const chartContainer = document.getElementById('chart-tracker');
            if (chartContainer) {
                chartContainer.innerHTML = '';
                const maxVal = Math.max(...state.arr, 50);
                
                state.arr.forEach((val, idx) => {
                    const bar = document.createElement('div');
                    bar.className = 'chart-bar';
                    bar.style.height = `${(val / maxVal) * 100}%`;
                    
                    if (state.swap && state.swap.includes(idx)) bar.classList.add('active');
                    else if (state.compare && state.compare.includes(idx)) bar.classList.add('compare');
                    else if (state.sorted && state.sorted.includes(idx)) bar.classList.add('sorted');
                    else if (state.active && state.active.includes(idx)) bar.classList.add('active');
                    
                    chartContainer.appendChild(bar);
                });
            }

            // 2. Render Array (Cells)
            const arrayContainer = document.getElementById('array-tracker');
            if (arrayContainer) {
                arrayContainer.innerHTML = '';
                const row = document.createElement('div');
                row.className = 'array-row';
                
                state.arr.forEach((val, idx) => {
                    const cell = document.createElement('div');
                    cell.className = 'array-cell';
                    cell.innerHTML = `${val}<span class="idx-label">${idx}</span>`;
                    
                    if (state.swap && state.swap.includes(idx)) cell.classList.add('active');
                    else if (state.compare && state.compare.includes(idx)) cell.classList.add('compare');
                    else if (state.sorted && state.sorted.includes(idx)) cell.classList.add('sorted');
                    else if (state.active && state.active.includes(idx)) cell.classList.add('active');
                    
                    row.appendChild(cell);
                });
                arrayContainer.appendChild(row);
            }

            // 3. Render Aux (Buckets)
            const auxWrapper = document.getElementById('aux-tracker-wrapper');
            const auxContainer = document.getElementById('aux-tracker');
            
            if (auxWrapper && auxContainer) {
                if (state.aux) {
                    auxWrapper.style.display = 'block';
                    auxContainer.innerHTML = '<div class="buckets-container"></div>';
                    const bucketContainer = auxContainer.querySelector('.buckets-container');
                    
                    state.aux.forEach((bucket, bIdx) => {
                        const label = state.auxLabels ? state.auxLabels[bIdx] : `B${bIdx}`;
                        const bDiv = document.createElement('div');
                        bDiv.className = 'bucket';
                        bDiv.innerHTML = `<div class="bucket-label">${label}</div>`;
                        
                        if (state.activeBucket === bIdx) {
                            bDiv.style.borderColor = 'var(--accent-color)';
                            bDiv.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                        }

                        bucket.forEach(val => {
                            const item = document.createElement('div');
                            item.className = 'bucket-item';
                            item.textContent = val;
                            bDiv.appendChild(item);
                        });
                        bucketContainer.appendChild(bDiv);
                    });
                } else {
                    auxWrapper.style.display = 'none';
                }
            }

            document.getElementById('status-text').textContent = state.msg;
            document.getElementById('step-counter').textContent = `Step ${stepIndex + 1} / ${steps.length}`;
            document.getElementById('explanation').textContent = state.msg;
            
            // Update Log
            if (state.log) {
                const logPanel = document.getElementById('log-panel');
                const entry = document.createElement('div');
                entry.className = 'log-entry highlight';
                entry.textContent = `[Step ${stepIndex}] ${state.log}`;
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
            }

            // Highlight Code
            if (state.lines) {
                document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
                const algo = currentAlgo;
                if (state.lines[currentLang]) {
                    const lineNum = state.lines[currentLang];
                    if (lineNum) {
                        const el = document.getElementById(`${algo}-${currentLang}-${lineNum}`);
                        if (el) {
                            el.classList.add('active');
                            el.scrollIntoView({behavior: "smooth", block: "nearest"});
                        }
                    }
                }
            }
        }

        function selectAlgo(algo) {
            currentAlgo = algo;
            // Update sidebar active state
            document.querySelectorAll('.sidebar .nav-item').forEach(el => {
                if (el.id && el.id.startsWith('nav-')) el.classList.remove('active');
            });
            const navEl = document.getElementById(`nav-${algo}`);
            if (navEl) navEl.classList.add('active');
            
            renderCode(algo, currentLang);
            reset();
        }

        function togglePlay() {
            if (isPlaying) {
                clearInterval(intervalId);
                isPlaying = false;
                document.getElementById('playBtn').textContent = "‚ñ∂ Play";
            } else {
                if (currentStep >= steps.length - 1) currentStep = 0;
                isPlaying = true;
                document.getElementById('playBtn').textContent = "‚è∏ Pause";
                intervalId = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        currentStep++;
                        render(currentStep);
                    } else {
                        togglePlay();
                    }
                }, ANIMATION_SPEED);
            }
        }

        function stepForward() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                render(currentStep);
            }
        }

        function stepBackward() {
            if (currentStep > 0) {
                currentStep--;
                render(currentStep);
            }
        }

        function reset() {
            if (isPlaying) togglePlay();
            array = Array.from({length: 15}, () => Math.floor(Math.random() * 20) + 1);
            currentStep = 0;
            document.getElementById('log-panel').innerHTML = '<div class="log-entry">Ready to start...</div>';
            generateSteps(currentAlgo);
            render(0);
        }

        function setSpeed(val) {
            ANIMATION_SPEED = Number(val);
            if (isPlaying) {
                togglePlay(); // Pause
                togglePlay(); // Resume with new speed
            }
        }

        function switchLang(lang) {
            currentLang = lang;
            const algo = currentAlgo;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            renderCode(algo, lang);
        }

        // Initialize
        renderCode('bubble', 'go');
        window.onload = init;
        window.onresize = () => render(currentStep);
    </script>
</body>
</html>