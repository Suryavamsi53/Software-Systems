<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Visualizer - Software Systems Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <style>
        /* Tracker Layout */
        .viz-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            overflow-y: auto;
            padding-right: 5px;
        }

        .tracker {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .tracker-header {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 4px 10px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
        }

        .tracker-content {
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 120px;
            position: relative;
        }

        /* Chart Tracker (Histogram) */
        .chart-bar {
            width: 20px;
            margin: 0 2px;
            background-color: #cbd5e1; /* Light gray default */
            transition: height 0.2s, background-color 0.2s;
            border-radius: 2px 2px 0 0;
        }
        .chart-bar.active { background-color: var(--accent-color); }
        .chart-bar.compare { background-color: #fb923c; }
        .chart-bar.sorted { background-color: #22c55e; }

        /* Array Tracker (Cells) */
        .array-row {
            display: flex;
            gap: 4px;
        }
        .array-cell {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            position: relative;
            background-color: var(--bg-primary);
            transition: all 0.2s;
        }
        .array-cell .idx-label {
            position: absolute;
            bottom: -18px;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        .array-cell.active { background-color: rgba(59, 130, 246, 0.2); border-color: var(--accent-color); }
        .array-cell.compare { background-color: rgba(251, 146, 60, 0.2); border-color: #fb923c; }
        .array-cell.sorted { background-color: rgba(34, 197, 94, 0.2); border-color: #22c55e; }

        /* Aux Tracker (Buckets) */
        .buckets-container {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            height: 100%;
        }
        .bucket {
            display: flex;
            flex-direction: column-reverse; /* Stack from bottom */
            width: 40px;
            min-height: 100px;
            border: 1px solid var(--border-color);
            border-top: none;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.02));
            position: relative;
            padding: 2px;
            gap: 2px;
        }
        .bucket-label {
            position: absolute;
            bottom: -20px;
            width: 100%;
            text-align: center;
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .bucket-item {
            width: 100%;
            height: 30px;
            background-color: var(--accent-color);
            color: #000;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 2px;
            animation: dropIn 0.3s ease-out;
        }
        @keyframes dropIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Log Panel */
        .log-section {
            height: 150px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 0 10px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            max-height: 400px;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
        .log-entry.highlight { color: var(--accent-color); }

        /* Explanation Panel */
        .explanation-panel {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(59, 130, 246, 0.1);
            border-left: 3px solid var(--accent-color);
            color: var(--text-primary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë Software Systems</h1>
                <p>Sorting Visualizer</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Back</div>
                <a href="../index.html" class="nav-item">‚Üê Dashboard</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Algorithms</div>
                <a href="javascript:void(0)" class="nav-item active" id="nav-bubble" onclick="selectAlgo('bubble')">Bubble Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-selection" onclick="selectAlgo('selection')">Selection Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-insertion" onclick="selectAlgo('insertion')">Insertion Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-merge" onclick="selectAlgo('merge')">Merge Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-quick" onclick="selectAlgo('quick')">Quick Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-heap" onclick="selectAlgo('heap')">Heap Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-counting" onclick="selectAlgo('counting')">Counting Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-radix" onclick="selectAlgo('radix')">Radix Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-bucket" onclick="selectAlgo('bucket')">Bucket Sort</a>
                <a href="javascript:void(0)" class="nav-item" id="nav-shell" onclick="selectAlgo('shell')">Shell Sort</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Controls</div>
                <div class="control-group">
                    <button class="action-btn" id="playBtn" onclick="togglePlay()">‚ñ∂ Play / Pause</button>
                    <button class="action-btn" onclick="stepBackward()">‚Ü© Step Backward</button>
                    <button class="action-btn" onclick="stepForward()">üëü Step Forward</button>
                    <button class="action-btn warning" onclick="reset()">Reset / Randomize</button>
                </div>
                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="speedRange" min="50" max="1000" step="50" value="400" onchange="setSpeed(this.value)" style="width: 100%">
                </div>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar">
                    <div id="status-text" style="font-family: monospace; color: var(--accent-color);">Ready.</div>
                    <div id="step-counter" style="font-family: monospace; color: var(--text-secondary); margin-left: auto;">Step 0 / 0</div>
                </div>
                
                <div class="split-view">
                    <!-- Visualization Trackers -->
                    <div class="canvas-section">
                        <div class="viz-container">
                            <div class="tracker">
                                <div class="tracker-header">Chart (Distribution)</div>
                                <div class="tracker-content" id="chart-tracker"></div>
                            </div>
                            <div class="tracker">
                                <div class="tracker-header">Array (Values)</div>
                                <div class="tracker-content" id="array-tracker"></div>
                            </div>
                            <div class="tracker" id="aux-tracker-wrapper" style="display: none;">
                                <div class="tracker-header">Auxiliary (Buckets / Temp)</div>
                                <div class="tracker-content" id="aux-tracker"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Log Panel -->
                    <div class="log-section" id="log-panel">
                        <div class="log-entry">Ready to start...</div>
                    </div>

                    <!-- Code Panel -->
                    <div class="code-section">
                        <div class="code-header">
                            <button class="action-btn" style="padding: 4px 10px; font-size: 0.8rem;" onclick="copyCode()">üìã Copy</button>
                            <span>Algorithm Code</span>
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go')">Go</button>
                                <button class="tab-btn" onclick="switchLang('java')">Java</button>
                                <button class="tab-btn" onclick="switchLang('python')">Python</button>
                            </div>
                        </div>

                        <div id="code-display" class="algo-code active">
                            <!-- Code will be injected here by JS -->
                        </div>
                        <div class="explanation-panel" id="explanation">
                            Algorithm explanation will appear here.
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Configuration
        let ANIMATION_SPEED = 400;
        let array = [15, 8, 20, 5, 12, 3, 10, 18];
        // For bucket sort, we might normalize or use specific values
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let intervalId = null;
        let currentLang = 'go';
        let currentAlgo = 'bubble';

        // Semantic Line Mapping
        const LINES = {
            bubble: {
                compare: { go: 4, java: 4, python: 4 },
                swap: { go: 5, java: 5, python: 5 },
                sorted: { go: 2, java: 2, python: 2 }
            },
            selection: {
                compare: { go: 5, java: 5, python: 5 },
                newMin: { go: 5, java: 5, python: 5 },
                swap: { go: 7, java: 7, python: 7 },
                sorted: { go: 2, java: 2, python: 2 }
            },
            insertion: {
                compare: { go: 4, java: 4, python: 4 },
                swap: { go: 5, java: 5, python: 5 },
                insert: { go: 7, java: 7, python: 7 },
                sorted: { go: 2, java: 2, python: 2 }
            },
            merge: {
                split: { go: 3, java: 3, python: 3 },
                merge: { go: 6, java: 6, python: 5 },
                compare: { go: 9, java: 9, python: 9 },
                overwrite: { go: 9, java: 9, python: 9 }
            },
            quick: {
                pivot: { go: 9, java: 8, python: 8 },
                compare: { go: 11, java: 8, python: 8 },
                swap: { go: 12, java: 8, python: 8 },
                placePivot: { go: 15, java: 8, python: 8 }
            },
            heap: {
                heapify: { go: 4, java: 4, python: 4 },
                extract: { go: 7, java: 7, python: 7 },
                compare: { go: 13, java: 14, python: 12 },
                swap: { go: 16, java: 17, python: 15 }
            },
            counting: {
                count: { go: 4, java: 4, python: 4 },
                place: { go: 8, java: 8, python: 8 }
            },
            radix: {
                digit: { go: 3, java: 3, python: 4 },
                count: { go: 4, java: 4, python: 5 }
            },
            bucket: {
                distribute: { go: 4, java: 7, python: 5 },
                sort: { go: 9, java: 10, python: 8 },
                collect: { go: 11, java: 12, python: 10 }
            },
            shell: {
                gap: { go: 3, java: 3, python: 4 },
                compare: { go: 7, java: 7, python: 8 },
                swap: { go: 8, java: 8, python: 9 },
                insert: { go: 10, java: 10, python: 11 }
            }
        };

        // Code Data Store
        const ALGO_CODES = {
            bubble: {
                go: `func bubbleSort(arr []int) {
  for i := 0; i < len(arr); i++ {
    for j := 0; j < len(arr)-i-1; j++ {
      if arr[j] > arr[j+1] {
        arr[j], arr[j+1] = arr[j+1], arr[j]
      }
    }
  }
}`,
                java: `void bubbleSort(int[] arr) {
  for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j+1]) {
        swap(arr, j, j+1);
      }
    }
  }
}`,
                python: `def bubble_sort(arr):
  for i in range(len(arr)):
    for j in range(len(arr) - i - 1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j]`
            },
            selection: {
                go: `func selectionSort(arr []int) {
  for i := 0; i < len(arr); i++ {
    minIdx := i
    for j := i + 1; j < len(arr); j++ {
      if arr[j] < arr[minIdx] { minIdx = j }
    }
    arr[i], arr[minIdx] = arr[minIdx], arr[i]
  }
}`,
                java: `void selectionSort(int[] arr) {
  for (int i = 0; i < arr.length; i++) {
    int minIdx = i;
    for (int j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIdx]) minIdx = j;
    }
    swap(arr, i, minIdx);
  }
}`,
                python: `def selection_sort(arr):
  for i in range(len(arr)):
    min_idx = i
    for j in range(i + 1, len(arr)):
      if arr[j] < arr[min_idx]: min_idx = j
    arr[i], arr[min_idx] = arr[min_idx], arr[i]`
            },
            insertion: {
                go: `func insertionSort(arr []int) {
  for i := 1; i < len(arr); i++ {
    key := arr[i]; j := i - 1
    for j >= 0 && arr[j] > key {
      arr[j+1] = arr[j]; j--
    }
    arr[j+1] = key
  }
}`,
                java: `void insertionSort(int[] arr) {
  for (int i = 1; i < arr.length; i++) {
    int key = arr[i]; int j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j+1] = arr[j]; j--;
    }
    arr[j+1] = key;
  }
}`,
                python: `def insertion_sort(arr):
  for i in range(1, len(arr)):
    key = arr[i]; j = i - 1
    while j >= 0 and arr[j] > key:
      arr[j+1] = arr[j]; j -= 1
    arr[j+1] = key`
            },
            merge: {
                go: `func mergeSort(arr []int) []int {
  if len(arr) <= 1 { return arr }
  mid := len(arr) / 2
  left := mergeSort(arr[:mid])
  right := mergeSort(arr[mid:])
  return merge(left, right)
}`,
                java: `void mergeSort(int[] arr, int l, int r) {
  if (l < r) {
    int m = (l + r) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
  }
}`,
                python: `def merge_sort(arr):
  if len(arr) > 1:
    mid = len(arr) // 2
    L = arr[:mid]; R = arr[mid:]
    merge_sort(L)
    merge_sort(R)
    # Merge L and R`
            },
            quick: {
                go: `func quickSort(arr []int, low, high int) {
  if low < high {
    p := partition(arr, low, high)
    quickSort(arr, low, p-1)
    quickSort(arr, p+1, high)
  }
}
func partition(arr []int, low, high int) int {
  pivot := arr[high]; i := low
  for j := low; j < high; j++ {
    if arr[j] < pivot {
      arr[i], arr[j] = arr[j], arr[i]; i++
    }
  }
  arr[i], arr[high] = arr[high], arr[i]
  return i
}`,
                java: `void quickSort(int[] arr, int low, int high) {
  if (low < high) {
    int pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}
int partition(int[] arr, int low, int high) { ... }`,
                python: `def quick_sort(arr, low, high):
  if low < high:
    pi = partition(arr, low, high)
    quick_sort(arr, low, pi - 1)
    quick_sort(arr, pi + 1, high)

def partition(arr, low, high):
  # Partition logic`
            },
            heap: {
                go: `func heapSort(arr []int) {
  n := len(arr)
  for i := n/2 - 1; i >= 0; i-- {
    heapify(arr, n, i)
  }
  for i := n - 1; i > 0; i-- {
    arr[0], arr[i] = arr[i], arr[0]
    heapify(arr, i, 0)
  }
}
func heapify(arr []int, n, i int) {
  largest := i
  l, r := 2*i+1, 2*i+2
  if l < n && arr[l] > arr[largest] { largest = l }
  if r < n && arr[r] > arr[largest] { largest = r }
  if largest != i {
    arr[i], arr[largest] = arr[largest], arr[i]
    heapify(arr, n, largest)
  }
}`,
                java: `void heapSort(int[] arr) {
  int n = arr.length;
  for (int i = n / 2 - 1; i >= 0; i--)
    heapify(arr, n, i);
  for (int i = n - 1; i > 0; i--) {
    swap(arr, 0, i);
    heapify(arr, i, 0);
  }
}
void heapify(int[] arr, int n, int i) {
  int largest = i;
  int l = 2 * i + 1;
  int r = 2 * i + 2;
  if (l < n && arr[l] > arr[largest]) largest = l;
  if (r < n && arr[r] > arr[largest]) largest = r;
  if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, n, largest);
  }
}`,
                python: `def heap_sort(arr):
  n = len(arr)
  for i in range(n // 2 - 1, -1, -1):
    heapify(arr, n, i)
  for i in range(n - 1, 0, -1):
    arr[i], arr[0] = arr[0], arr[i]
    heapify(arr, i, 0)

def heapify(arr, n, i):
  largest = i
  l, r = 2 * i + 1, 2 * i + 2
  if l < n and arr[l] > arr[largest]: largest = l
  if r < n and arr[r] > arr[largest]: largest = r
  if largest != i:
    arr[i], arr[largest] = arr[largest], arr[i]
    heapify(arr, n, largest)`
            },
            counting: {
                go: `func countingSort(arr []int) {
  max := findMax(arr)
  count := make([]int, max+1)
  for _, x := range arr { count[x]++ }
  idx := 0
  for i, c := range count {
    for c > 0 {
      arr[idx] = i
      idx++; c--
    }
  }
}`,
                java: `void countingSort(int[] arr) {
  int max = findMax(arr);
  int[] count = new int[max + 1];
  for (int x : arr) count[x]++;
  int idx = 0;
  for (int i = 0; i <= max; i++) {
    while (count[i] > 0) {
      arr[idx++] = i;
      count[i]--;
    }
  }
}`,
                python: `def counting_sort(arr):
  max_val = max(arr)
  count = [0] * (max_val + 1)
  for x in arr: count[x] += 1
  idx = 0
  for i in range(len(count)):
    while count[i] > 0:
      arr[idx] = i
      idx += 1; count[i] -= 1`
            },
            radix: {
                go: `func radixSort(arr []int) {
  max := getMax(arr)
  for exp := 1; max/exp > 0; exp *= 10 {
    countingSortByDigit(arr, exp)
  }
}`,
                java: `void radixSort(int[] arr) {
  int max = getMax(arr);
  for (int exp = 1; max/exp > 0; exp *= 10) {
    countSort(arr, exp);
  }
}`,
                python: `def radix_sort(arr):
  max_val = max(arr)
  exp = 1
  while max_val // exp > 0:
    counting_sort(arr, exp)
    exp *= 10`
            },
            bucket: {
                go: `func bucketSort(arr []int) {
  buckets := make([][]int, len(arr))
  for _, num := range arr {
    idx := (num * len(arr)) / (max + 1)
    buckets[idx] = append(buckets[idx], num)
  }
  idx := 0
  for _, bucket := range buckets {
    sort.Ints(bucket)
    for _, num := range bucket {
      arr[idx] = num; idx++
    }
  }
}`,
                java: `void bucketSort(float[] arr) {
  int n = arr.length;
  ArrayList[] buckets = new ArrayList[n];
  for (int i=0; i<n; i++) buckets[i] = new ArrayList<>();
  for (float num : arr) {
    int idx = (int)num * n;
    buckets[idx].add(num);
  }
  for (int i=0; i<n; i++) {
    Collections.sort(buckets[i]);
    for (float num : buckets[i]) {
      arr[idx++] = num;
    }
  }
}`,
                python: `def bucket_sort(arr):
  buckets = [[] for _ in range(len(arr))]
  for num in arr:
    idx = int(num * len(arr))
    buckets[idx].append(num)
  idx = 0
  for bucket in buckets:
    bucket.sort()
    for num in bucket:
      arr[idx] = num
      idx += 1`
            },
            shell: {
                go: `func shellSort(arr []int) {
  n := len(arr)
  for gap := n/2; gap > 0; gap /= 2 {
    for i := gap; i < n; i++ {
      temp := arr[i]
      j := i
      for ; j >= gap && arr[j-gap] > temp; j -= gap {
        arr[j] = arr[j-gap]
      }
      arr[j] = temp
    }
  }
}`,
                java: `void shellSort(int[] arr) {
  int n = arr.length;
  for (int gap = n/2; gap > 0; gap /= 2) {
    for (int i = gap; i < n; i++) {
      int temp = arr[i];
      int j;
      for (j = i; j >= gap && arr[j-gap] > temp; j -= gap) {
        arr[j] = arr[j-gap];
      }
      arr[j] = temp;
    }
  }
}`,
                python: `def shell_sort(arr):
  n = len(arr)
  gap = n // 2
  while gap > 0:
    for i in range(gap, n):
      temp = arr[i]
      j = i
      while j >= gap and arr[j-gap] > temp:
        arr[j] = arr[j-gap]
        j -= gap
      arr[j] = temp
    gap //= 2`
            }
        };

        function init() {
            reset();
        }

        // Helper to create a standard step object
        function createStep(type, arr, msg, lines, extras = {}) {
            return { type, arr: [...arr], msg, lines, log: msg, ...extras };
        }

        function generateSteps(type) {
            steps = [];
            let arr = [...array];
            
            if (type === 'bubble') {
                for (let i = 0; i < arr.length; i++) {
                    for (let j = 0; j < arr.length - i - 1; j++) {
                        steps.push(createStep('COMPARE', arr, `Compare ${arr[j]} > ${arr[j+1]}?`, LINES.bubble.compare, { compare: [j, j+1] }));
                        if (arr[j] > arr[j+1]) {
                            [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
                            steps.push(createStep('SWAP', arr, 'Swap!', LINES.bubble.swap, { swap: [j, j+1] }));
                        }
                    }
                    steps.push(createStep('SORTED', arr, 'Element sorted', LINES.bubble.sorted, { sorted: Array.from({length: i+1}, (_, k) => arr.length-1-k) }));
                }
            } else if (type === 'selection') {
                for (let i = 0; i < arr.length; i++) {
                    let minIdx = i;
                    steps.push(createStep('SELECT', arr, `Current min index: ${i}`, LINES.selection.sorted, { active: [i] }));
                    for (let j = i + 1; j < arr.length; j++) {
                        steps.push(createStep('COMPARE', arr, `Check ${arr[j]} < ${arr[minIdx]}?`, LINES.selection.compare, { active: [i], compare: [j, minIdx] }));
                        if (arr[j] < arr[minIdx]) {
                            minIdx = j;
                            steps.push(createStep('NEW_MIN', arr, `New min found: ${arr[minIdx]}`, LINES.selection.newMin, { active: [i], swap: [minIdx] }));
                        }
                    }
                    if (minIdx !== i) {
                        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                        steps.push(createStep('SWAP', arr, `Swap min ${arr[i]} to position ${i}`, LINES.selection.swap, { swap: [i, minIdx] }));
                    }
                }
            } else if (type === 'insertion') {
                for (let i = 1; i < arr.length; i++) {
                    let key = arr[i];
                    let j = i - 1;
                    steps.push(createStep('SELECT', arr, `Insert ${key}`, {go: 3, java: 3, python: 3}, { active: [i] }));
                    while (j >= 0 && arr[j] > key) {
                        steps.push(createStep('COMPARE', arr, `${arr[j]} > ${key}, shift right`, LINES.insertion.compare, { compare: [j] }));
                        arr[j + 1] = arr[j];
                        j = j - 1;
                        steps.push(createStep('SHIFT', arr, 'Shifted', LINES.insertion.swap, { swap: [j+1] }));
                    }
                    arr[j + 1] = key;
                    steps.push(createStep('INSERT', arr, `Placed ${key}`, LINES.insertion.insert, { sorted: [j+1] }));
                }
            } else if (type === 'merge') {
                function mergeSortHelper(arr, start, end) {
                    if (start >= end) return;
                    const mid = Math.floor((start + end) / 2);
                    steps.push(createStep('SPLIT', arr, `Split at index ${mid}`, LINES.merge.split, { range: [start, end], active: [mid] }));
                    
                    mergeSortHelper(arr, start, mid);
                    mergeSortHelper(arr, mid + 1, end);
                    merge(arr, start, mid, end);
                }

                function merge(arr, start, mid, end) {
                    let left = arr.slice(start, mid + 1);
                    let right = arr.slice(mid + 1, end + 1);
                    let i = 0, j = 0, k = start;
                    
                    steps.push(createStep('MERGE_START', arr, `Merging range [${start}, ${end}]`, LINES.merge.merge, { range: [start, end], active: Array.from({length: end-start+1}, (_, idx) => start+idx) }));

                    while (i < left.length && j < right.length) {
                        steps.push(createStep('COMPARE', arr, `Compare ${left[i]} vs ${right[j]}`, LINES.merge.compare, { range: [start, end], compare: [start+i, mid+1+j] }));
                        if (left[i] <= right[j]) {
                            arr[k] = left[i];
                            i++;
                        } else {
                            arr[k] = right[j];
                            j++;
                        }
                        steps.push(createStep('OVERWRITE', arr, `Placed ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k] }));
                        k++;
                    }
                    while (i < left.length) {
                        arr[k] = left[i];
                        steps.push(createStep('OVERWRITE', arr, `Placed remaining ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k] }));
                        i++; k++;
                    }
                    while (j < right.length) {
                        arr[k] = right[j];
                        steps.push(createStep('OVERWRITE', arr, `Placed remaining ${arr[k]}`, LINES.merge.overwrite, { range: [start, end], sorted: [k] }));
                        j++; k++;
                    }
                }
                mergeSortHelper(arr, 0, arr.length - 1);

            } else if (type === 'quick') {
                function quickSortHelper(arr, low, high) {
                    if (low < high) {
                        let pi = partition(arr, low, high);
                        quickSortHelper(arr, low, pi - 1);
                        quickSortHelper(arr, pi + 1, high);
                    }
                }

                function partition(arr, low, high) {
                    let pivot = arr[high];
                    let i = (low - 1);
                    steps.push(createStep('PIVOT', arr, `Pivot chosen: ${pivot}`, LINES.quick.pivot, { active: [high] }));

                    for (let j = low; j <= high - 1; j++) {
                        steps.push(createStep('COMPARE', arr, `Compare ${arr[j]} < ${pivot}?`, LINES.quick.compare, { compare: [j, high] }));
                        if (arr[j] < pivot) {
                            i++;
                            [arr[i], arr[j]] = [arr[j], arr[i]];
                            steps.push(createStep('SWAP', arr, `Swap ${arr[i]} and ${arr[j]}`, LINES.quick.swap, { swap: [i, j] }));
                        }
                    }
                    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                    steps.push(createStep('PLACE_PIVOT', arr, `Pivot placed at ${i+1}`, LINES.quick.placePivot, { swap: [i+1, high], sorted: [i+1] }));
                    return (i + 1);
                }
                quickSortHelper(arr, 0, arr.length - 1);
            } else if (type === 'heap') {
                function heapify(arr, n, i) {
                    let largest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;

                    if (l < n) {
                        steps.push({ type: 'COMPARE', arr: [...arr], compare: [l, largest], msg: `Compare left child ${arr[l]} > ${arr[largest]}?`, lines: LINES.heap.compare });
                        if (arr[l] > arr[largest]) largest = l;
                    }

                    if (r < n) {
                        steps.push({ type: 'COMPARE', arr: [...arr], compare: [r, largest], msg: `Compare right child ${arr[r]} > ${arr[largest]}?`, lines: LINES.heap.compare });
                        if (arr[r] > arr[largest]) largest = r;
                    }

                    if (largest !== i) {
                        [arr[i], arr[largest]] = [arr[largest], arr[i]];
                        steps.push({ type: 'SWAP', arr: [...arr], swap: [i, largest], msg: `Swap root ${arr[largest]} with largest child ${arr[i]}`, lines: LINES.heap.swap, log: `Heapify: Swapped index ${i} and ${largest}` });
                        heapify(arr, n, largest);
                    }
                }

                let n = arr.length;
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    steps.push({ type: 'HEAPIFY', arr: [...arr], active: [i], msg: `Building heap from index ${i}`, lines: LINES.heap.heapify });
                    heapify(arr, n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    [arr[0], arr[i]] = [arr[i], arr[0]];
                    steps.push({ type: 'EXTRACT', arr: [...arr], swap: [0, i], sorted: [i], msg: `Move max ${arr[i]} to end`, lines: LINES.heap.extract, log: `Extracted max ${arr[i]}` });
                    heapify(arr, i, 0);
                }
            } else if (type === 'counting') {
                let max = Math.max(...arr);
                let count = new Array(max + 1).fill(0);
                
                steps.push({ type: 'INIT', arr: [...arr], msg: `Find max value: ${max}`, lines: {go: 2, java: 2, python: 2} });
                
                for (let i = 0; i < arr.length; i++) {
                    count[arr[i]]++;
                    steps.push({ type: 'COUNT', arr: [...arr], active: [i], msg: `Count ${arr[i]}: ${count[arr[i]]}`, lines: LINES.counting.count, log: `Counting occurrence of ${arr[i]}` });
                }
                
                let idx = 0;
                for (let i = 0; i <= max; i++) {
                    while (count[i] > 0) {
                        arr[idx] = i;
                        steps.push({ type: 'PLACE', arr: [...arr], sorted: [idx], msg: `Place ${i} at index ${idx}`, lines: LINES.counting.place, log: `Placed ${i} at index ${idx}` });
                        idx++;
                        count[i]--;
                    }
                }
            } else if (type === 'radix') {
                let max = Math.max(...arr);
                for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                    steps.push({ type: 'DIGIT', arr: [...arr], msg: `Sorting by digit at ${exp}`, lines: LINES.radix.digit, log: `Processing digit position ${exp}` });
                    
                    let output = new Array(arr.length).fill(0);
                    let count = new Array(10).fill(0);
                    
                    for (let i = 0; i < arr.length; i++) {
                        count[Math.floor(arr[i] / exp) % 10]++;
                    }
                    for (let i = 1; i < 10; i++) {
                        count[i] += count[i - 1];
                    }
                    for (let i = arr.length - 1; i >= 0; i--) {
                        let digit = Math.floor(arr[i] / exp) % 10;
                        output[count[digit] - 1] = arr[i];
                        count[digit]--;
                    }
                    for (let i = 0; i < arr.length; i++) {
                        arr[i] = output[i];
                        steps.push({ type: 'UPDATE', arr: [...arr], active: [i], msg: `Update index ${i} with ${arr[i]}`, lines: LINES.radix.count, log: `Updated index ${i} to ${arr[i]}` });
                    }
                }
            } else if (type === 'bucket') {
                // Normalize array to 0-1 range for visualization logic, but keep original values for display
                // For simplicity, let's assume input is scaled down or we use buckets based on max value
                let max = Math.max(...arr);
                let n = arr.length;
                // Use 5 buckets for visualization clarity
                let bucketCount = 5;
                let buckets = Array.from({length: bucketCount}, () => []);
                
                steps.push(createStep('INIT', arr, `Create ${bucketCount} buckets`, {go: 2, java: 3, python: 2}, { aux: JSON.parse(JSON.stringify(buckets)) }));
                
                for (let i = 0; i < n; i++) {
                    let idx = Math.floor((arr[i] / (max + 1)) * bucketCount);
                    buckets[idx].push(arr[i]);
                    steps.push(createStep('DISTRIBUTE', arr, `Place ${arr[i]} into bucket ${idx}`, LINES.bucket.distribute, { active: [i], aux: JSON.parse(JSON.stringify(buckets)), activeBucket: idx }));
                }
                
                let idx = 0;
                for (let i = 0; i < bucketCount; i++) {
                    if (buckets[i].length > 0) {
                        buckets[i].sort((a, b) => a - b);
                        steps.push(createStep('SORT_BUCKET', arr, `Sort bucket ${i}`, LINES.bucket.sort, { aux: JSON.parse(JSON.stringify(buckets)), activeBucket: i }));
                        for (let val of buckets[i]) {
                            arr[idx] = val;
                            steps.push(createStep('COLLECT', arr, `Place ${val} back into array`, LINES.bucket.collect, { sorted: [idx], aux: JSON.parse(JSON.stringify(buckets)), activeBucket: i }));
                            idx++;
                        }
                    }
                }
            } else if (type === 'shell') {
                let n = arr.length;
                for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                    steps.push({ type: 'GAP', arr: [...arr], msg: `Gap size: ${gap}`, lines: LINES.shell.gap, log: `Gap set to ${gap}` });
                    
                    for (let i = gap; i < n; i++) {
                        let temp = arr[i];
                        let j;
                        steps.push({ type: 'INSERT_START', arr: [...arr], active: [i], msg: `Insert ${temp} into gap-sorted subarray`, lines: LINES.shell.insert });
                        for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                            steps.push({ type: 'COMPARE', arr: [...arr], compare: [j, j-gap], msg: `${arr[j-gap]} > ${temp}, shift right`, lines: LINES.shell.compare });
                            arr[j] = arr[j - gap];
                            steps.push({ type: 'SHIFT', arr: [...arr], swap: [j], msg: `Shifted ${arr[j]}`, lines: LINES.shell.swap, log: `Shifted ${arr[j]} right` });
                        }
                        arr[j] = temp;
                        steps.push({ type: 'PLACE', arr: [...arr], sorted: [j], msg: `Placed ${temp} at index ${j}`, lines: LINES.shell.insert, log: `Placed ${temp} at ${j}` });
                    }
                }
            }
            
            steps.push({ type: 'DONE', arr: [...arr], sorted: arr.map((_, i) => i), msg: 'Sorted!', lines: {go: 9, java: 9, python: 9}, log: 'Sorting complete' });
        }

        function renderCode(algo, lang) {
            const codeContainer = document.getElementById('code-display');
            const code = ALGO_CODES[algo] && ALGO_CODES[algo][lang] ? ALGO_CODES[algo][lang] : "// Code not available";
            
            // Split into lines and wrap
            const lines = code.split('\n');
            let html = '';
            lines.forEach((line, i) => {
                // Simple syntax highlighting (very basic)
                let formatted = line.replace(/\b(func|void|def|for|if|return|int|var)\b/g, '<span class="kwd">$1</span>');
                html += `<div class="code-line" id="${algo}-${lang}-${i+1}"><span class="ln">${i+1}</span>${formatted}</div>`;
            });
            codeContainer.innerHTML = html;
        }

        function copyCode() {
            const code = ALGO_CODES[currentAlgo] && ALGO_CODES[currentAlgo][currentLang] ? ALGO_CODES[currentAlgo][currentLang] : "";
            navigator.clipboard.writeText(code);
        }

        function render(stepIndex) {
            const state = steps[stepIndex];
            
            // 1. Render Chart (Histogram)
            const chartContainer = document.getElementById('chart-tracker');
            if (chartContainer) {
                chartContainer.innerHTML = '';
                const maxVal = Math.max(...state.arr, 50);
                
                state.arr.forEach((val, idx) => {
                    const bar = document.createElement('div');
                    bar.className = 'chart-bar';
                    bar.style.height = `${(val / maxVal) * 100}%`;
                    
                    if (state.swap && state.swap.includes(idx)) bar.classList.add('active');
                    else if (state.compare && state.compare.includes(idx)) bar.classList.add('compare');
                    else if (state.sorted && state.sorted.includes(idx)) bar.classList.add('sorted');
                    else if (state.active && state.active.includes(idx)) bar.classList.add('active');
                    
                    chartContainer.appendChild(bar);
                });
            }

            // 2. Render Array (Cells)
            const arrayContainer = document.getElementById('array-tracker');
            if (arrayContainer) {
                arrayContainer.innerHTML = '';
                const row = document.createElement('div');
                row.className = 'array-row';
                
                state.arr.forEach((val, idx) => {
                    const cell = document.createElement('div');
                    cell.className = 'array-cell';
                    cell.innerHTML = `${val}<span class="idx-label">${idx}</span>`;
                    
                    if (state.swap && state.swap.includes(idx)) cell.classList.add('active');
                    else if (state.compare && state.compare.includes(idx)) cell.classList.add('compare');
                    else if (state.sorted && state.sorted.includes(idx)) cell.classList.add('sorted');
                    else if (state.active && state.active.includes(idx)) cell.classList.add('active');
                    
                    row.appendChild(cell);
                });
                arrayContainer.appendChild(row);
            }

            // 3. Render Aux (Buckets)
            const auxWrapper = document.getElementById('aux-tracker-wrapper');
            const auxContainer = document.getElementById('aux-tracker');
            
            if (auxWrapper && auxContainer) {
                if (state.aux) {
                    auxWrapper.style.display = 'block';
                    auxContainer.innerHTML = '<div class="buckets-container"></div>';
                    const bucketContainer = auxContainer.querySelector('.buckets-container');
                    
                    state.aux.forEach((bucket, bIdx) => {
                        const bDiv = document.createElement('div');
                        bDiv.className = 'bucket';
                        bDiv.innerHTML = `<div class="bucket-label">B${bIdx}</div>`;
                        
                        if (state.activeBucket === bIdx) {
                            bDiv.style.borderColor = 'var(--accent-color)';
                            bDiv.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                        }

                        bucket.forEach(val => {
                            const item = document.createElement('div');
                            item.className = 'bucket-item';
                            item.textContent = val;
                            bDiv.appendChild(item);
                        });
                        bucketContainer.appendChild(bDiv);
                    });
                } else {
                    auxWrapper.style.display = 'none';
                }
            }

            document.getElementById('status-text').textContent = state.msg;
            document.getElementById('step-counter').textContent = `Step ${stepIndex + 1} / ${steps.length}`;
            document.getElementById('explanation').textContent = state.msg;
            
            // Update Log
            if (state.log) {
                const logPanel = document.getElementById('log-panel');
                const entry = document.createElement('div');
                entry.className = 'log-entry highlight';
                entry.textContent = `[Step ${stepIndex}] ${state.log}`;
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
            }

            // Highlight Code
            if (state.lines) {
                document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
                const algo = currentAlgo;
                if (state.lines[currentLang]) {
                    const lineNum = state.lines[currentLang];
                    if (lineNum) {
                        const el = document.getElementById(`${algo}-${currentLang}-${lineNum}`);
                        if (el) el.classList.add('active');
                        el.scrollIntoView({behavior: "smooth", block: "nearest"});
                    }
                }
            }
        }

        function selectAlgo(algo) {
            currentAlgo = algo;
            // Update sidebar active state
            document.querySelectorAll('.sidebar .nav-item').forEach(el => {
                if (el.id && el.id.startsWith('nav-')) el.classList.remove('active');
            });
            const navEl = document.getElementById(`nav-${algo}`);
            if (navEl) navEl.classList.add('active');
            
            reset();
            renderCode(algo, currentLang);
            generateSteps(algo);
        }

        function togglePlay() {
            if (isPlaying) {
                clearInterval(intervalId);
                isPlaying = false;
                document.getElementById('playBtn').textContent = "‚ñ∂ Play";
            } else {
                if (currentStep >= steps.length - 1) currentStep = 0;
                isPlaying = true;
                document.getElementById('playBtn').textContent = "‚è∏ Pause";
                intervalId = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        currentStep++;
                        render(currentStep);
                    } else {
                        togglePlay();
                    }
                }, ANIMATION_SPEED);
            }
        }

        function stepForward() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                render(currentStep);
            }
        }

        function stepBackward() {
            if (currentStep > 0) {
                currentStep--;
                render(currentStep);
            }
        }

        function reset() {
            if (isPlaying) togglePlay();
            array = Array.from({length: 15}, () => Math.floor(Math.random() * 50) + 1);
            currentStep = 0;
            document.getElementById('log-panel').innerHTML = '<div class="log-entry">Ready to start...</div>';
            generateSteps(currentAlgo);
            render(0);
        }

        function setSpeed(val) {
            ANIMATION_SPEED = Number(val);
            if (isPlaying) {
                togglePlay(); // Pause
                togglePlay(); // Resume with new speed
            }
        }

        function switchLang(lang) {
            currentLang = lang;
            const algo = currentAlgo;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            renderCode(algo, lang);
        }

        // Initialize
        renderCode('bubble', 'go');
        window.onload = init;
        window.onresize = () => render(currentStep);
    </script>
</body>
</html>