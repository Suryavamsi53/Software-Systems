<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort Visualizer - Software Systems Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <!-- Prism.js for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Custom styles for Topo Sort specific elements */
        .node circle {
            transition: all 0.3s ease;
            fill: var(--bg-tertiary);
            stroke: var(--text-secondary);
            stroke-width: 2px;
        }
        .node.active circle { stroke: var(--accent-color); stroke-width: 3px; fill: rgba(59, 130, 246, 0.2); }
        .node.processed circle { stroke: #22c55e; fill: rgba(34, 197, 94, 0.2); }
        .node.queue circle { stroke: #facc15; fill: rgba(250, 204, 21, 0.2); }
        
        .node text {
            font-weight: bold;
            pointer-events: none;
            fill: var(--text-primary);
            text-anchor: middle;
            dominant-baseline: middle;
            font-family: monospace;
            font-size: 14px;
        }

        .edge {
            stroke: var(--text-muted);
            stroke-width: 2px;
            marker-end: url(#arrow);
            transition: all 0.3s ease;
        }
        .edge.active { stroke: var(--accent-color); stroke-width: 3px; marker-end: url(#arrow-active); }
        .edge.faded { opacity: 0.2; }

        .badge-bg { fill: var(--danger); transition: fill 0.3s; }
        .badge-bg.zero { fill: #22c55e; }
        .badge { fill: white; font-size: 10px; font-weight: bold; text-anchor: middle; dominant-baseline: middle; }

        /* Queue & Result Panels */
        .panel-container {
            padding: 10px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .data-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .data-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            width: 80px;
        }
        .data-content {
            flex: 1;
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        .data-item {
            padding: 4px 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.85rem;
            white-space: nowrap;
            color: var(--text-primary);
        }
        
        /* Code Panel Styles Override */
        .code-section {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .code-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(255,255,255,0.05);
        }
        .algo-code {
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            flex: 1;
        }
        .code-line { padding: 2px 5px; border-radius: 4px; white-space: pre; }
        .code-line.active {
            background-color: rgba(250, 204, 21, 0.2);
            border-left: 3px solid #facc15;
            color: #facc15;
        }
        .ln { color: var(--text-muted); margin-right: 10px; user-select: none; display: inline-block; width: 20px; text-align: right; }
        .kwd { color: #f472b6; } 
        .com { color: #6b7280; font-style: italic; }
        .typ { color: #60a5fa; }
        .num { color: #facc15; }

        .cycle-warning {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid #ef4444;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë Software Systems</h1>
                <p>Topo Sort</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Back</div>
                <a href="../index.html" class="nav-item">‚Üê Dashboard</a>
                <a href="graphs.html" class="nav-item">‚Üê Graphs Pattern</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Controls</div>
                <div class="control-group">
                    <label>Scenario</label>
                    <select id="scenario-select" onchange="loadScenario(this.value)" style="width: 100%; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                        <option value="random">üé≤ Random Graph</option>
                        <option value="course">üìö Course Prerequisites</option>
                        <option value="build">üî® Build System</option>
                        <option value="cicd">‚öôÔ∏è CI/CD Pipeline</option>
                        <option value="recipe">üç≥ Recipe Steps</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Mode</label>
                    <select id="mode-select" onchange="setMode(this.value)" style="width: 100%; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                        <option value="beginner">üë∂ Beginner Mode (Guided)</option>
                        <option value="intermediate">üéì Intermediate Mode (Predict)</option>
                        <option value="expert">üöÄ Expert Mode (Manual)</option>
                    </select>
                </div>
                <div class="control-group">
                    <button class="action-btn warning" onclick="reset()">Reset</button>
                </div>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Legend</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); display: flex; flex-direction: column; gap: 5px;">
                    <div style="display: flex; align-items: center; gap: 8px;"><span style="width: 12px; height: 12px; background: #3b82f6; border-radius: 50%;"></span> Active</div>
                    <div style="display: flex; align-items: center; gap: 8px;"><span style="width: 12px; height: 12px; background: #22c55e; border-radius: 50%;"></span> Processed</div>
                    <div style="display: flex; align-items: center; gap: 8px;"><span style="width: 12px; height: 12px; background: #facc15; border-radius: 50%;"></span> In Queue</div>
                    <div style="display: flex; align-items: center; gap: 8px;"><span style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%;"></span> Dependency</div>
                </div>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar">
                    <div class="playback-controls">
                        <button id="btn-play" onclick="togglePlay()">‚ñ∂ Play</button>
                        <button id="btn-step" onclick="stepForward()">üëü Step</button>
                        <button id="btn-back" onclick="stepBackward()">‚Ü© Back</button>
                        <input type="range" id="speed-range" min="100" max="2000" value="1000" oninput="setSpeed(this.value)" title="Speed">
                    </div>
                    <div id="status-msg" style="margin-left: auto; font-family: monospace; color: var(--accent-color);">Ready.</div>
                    <div id="step-counter" style="margin-left: 15px; font-family: monospace; color: var(--text-muted);">Step 0/0</div>
                </div>
                
                <div class="split-view">
                    <!-- Left: Canvas -->
                    <div class="canvas-section">
                        <svg id="graph-svg" width="100%" height="100%">
                            <defs>
                                <marker id="arrow" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" />
                                </marker>
                                <marker id="arrow-active" markerWidth="10" markerHeight="10" refX="22" refY="3" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L0,6 L9,3 z" fill="#3b82f6" />
                                </marker>
                            </defs>
                        </svg>
                        
                        <div id="cycle-warning" class="cycle-warning">
                            <h3 style="color: #ef4444; margin-top: 0;">‚ö†Ô∏è Cycle Detected!</h3>
                            <p style="color: var(--text-primary);">Topological Sort is not possible on cyclic graphs.</p>
                            <button class="action-btn" onclick="reset()">Reset</button>
                        </div>

                        <div class="panel-container">
                            <div class="data-row">
                                <div class="data-label">Queue (0 In-Deg)</div>
                                <div class="data-content" id="queue-viz"></div>
                            </div>
                            <div class="data-row">
                                <div class="data-label">Result Order</div>
                                <div class="data-content" id="result-viz"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: Code -->
                    <div class="code-section">
                        <div class="code-header">
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go')">Go</button>
                                <button class="tab-btn" onclick="switchLang('java')">Java</button>
                                <button class="tab-btn" onclick="switchLang('python')">Python</button>
                            </div>
                        </div>
                        <div id="code-display" class="algo-code"></div>
                        <div style="padding: 15px; border-top: 1px solid var(--border-color); background: rgba(0,0,0,0.2);">
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Explanation</div>
                            <div id="explanation" style="font-size: 0.9rem; color: var(--text-primary); line-height: 1.4;">
                                Ready to start. Kahn's Algorithm repeatedly removes nodes with 0 in-degree.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    
    <script>
        // --- Configuration & State ---
        const width = 800, height = 600;
        let nodes = [];
        let edges = [];
        let simulation = null;
        let svg = d3.select("#graph-svg");
        
        // Algorithm State
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let speed = 1000;
        let timer = null;
        let mode = 'beginner'; // beginner, intermediate, expert
        let currentLang = 'go';
        
        // --- Scenarios ---
        const SCENARIOS = {
            random: {
                nodes: [
                    { id: 'A', label: 'A' }, { id: 'B', label: 'B' }, { id: 'C', label: 'C' },
                    { id: 'D', label: 'D' }, { id: 'E', label: 'E' }, { id: 'F', label: 'F' }
                ],
                edges: [
                    { from: 'A', to: 'B' }, { from: 'A', to: 'C' },
                    { from: 'B', to: 'D' }, { from: 'C', to: 'D' },
                    { from: 'D', to: 'E' }, { from: 'E', to: 'F' }
                ]
            },
            course: {
                nodes: [
                    { id: 'CS101', label: 'CS101' }, { id: 'CS102', label: 'CS102' },
                    { id: 'DATA', label: 'Data Struct' }, { id: 'ALGO', label: 'Algorithms' },
                    { id: 'OS', label: 'OS' }, { id: 'NET', label: 'Networks' }
                ],
                edges: [
                    { from: 'CS101', to: 'CS102' }, { from: 'CS102', to: 'DATA' },
                    { from: 'DATA', to: 'ALGO' }, { from: 'CS102', to: 'OS' },
                    { from: 'OS', to: 'NET' }
                ]
            },
            build: {
                nodes: [
                    { id: 'src', label: 'Source' }, { id: 'lib', label: 'Library' },
                    { id: 'comp', label: 'Compile' }, { id: 'link', label: 'Link' },
                    { id: 'test', label: 'Test' }, { id: 'pkg', label: 'Package' }
                ],
                edges: [
                    { from: 'src', to: 'comp' }, { from: 'lib', to: 'comp' },
                    { from: 'comp', to: 'link' }, { from: 'link', to: 'test' },
                    { from: 'test', to: 'pkg' }
                ]
            },
            cicd: {
                nodes: [
                    { id: 'git', label: 'Git Push' }, { id: 'build', label: 'Build' },
                    { id: 'unit', label: 'Unit Tests' }, { id: 'int', label: 'Integration' },
                    { id: 'deploy', label: 'Deploy' }, { id: 'monitor', label: 'Monitor' }
                ],
                edges: [
                    { from: 'git', to: 'build' }, { from: 'build', to: 'unit' },
                    { from: 'unit', to: 'int' }, { from: 'int', to: 'deploy' },
                    { from: 'deploy', to: 'monitor' }
                ]
            },
            recipe: {
                nodes: [
                    { id: 'prep', label: 'Prep' }, { id: 'mix', label: 'Mix' },
                    { id: 'oven', label: 'Preheat' }, { id: 'bake', label: 'Bake' },
                    { id: 'cool', label: 'Cool' }, { id: 'eat', label: 'Eat' }
                ],
                edges: [
                    { from: 'prep', to: 'mix' }, { from: 'oven', to: 'bake' },
                    { from: 'mix', to: 'bake' }, { from: 'bake', to: 'cool' },
                    { from: 'cool', to: 'eat' }
                ]
            }
        };

        // --- Code Snippets ---
        const CODE_SNIPPETS = {
            go: `func kahn(n int, edges [][]int) []int {
    adj := make([][]int, n)
    inDegree := make([]int, n)
    for _, e := range edges {
        adj[e[0]] = append(adj[e[0]], e[1])
        inDegree[e[1]]++
    }
    
    queue := []int{}
    for i, d := range inDegree {
        if d == 0 { queue = append(queue, i) }
    }
    
    res := []int{}
    for len(queue) > 0 {
        u := queue[0]; queue = queue[1:]
        res = append(res, u)
        
        for _, v := range adj[u] {
            inDegree[v]--
            if inDegree[v] == 0 {
                queue = append(queue, v)
            }
        }
    }
    return res
}`,
            java: `public List<Integer> kahn(int n, int[][] edges) {
    List<List<Integer>> adj = new ArrayList<>();
    int[] inDegree = new int[n];
    for (int i=0; i<n; i++) adj.add(new ArrayList<>());
    for (int[] e : edges) {
        adj.get(e[0]).add(e[1]);
        inDegree[e[1]]++;
    }
    
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; i++) 
        if (inDegree[i] == 0) q.add(i);
        
    List<Integer> res = new ArrayList<>();
    while (!q.isEmpty()) {
        int u = q.poll();
        res.add(u);
        
        for (int v : adj.get(u)) {
            inDegree[v]--;
            if (inDegree[v] == 0) q.add(v);
        }
    }
    return res;
}`,
            python: `def kahn(n, edges):
    adj = defaultdict(list)
    in_degree = [0] * n
    for u, v in edges:
        adj[u].append(v)
        in_degree[v] += 1
        
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    res = []
    
    while queue:
        u = queue.popleft()
        res.append(u)
        
        for v in adj[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
                
    return res`
        };

        const LINE_MAP = {
            go: { init: 2, q_init: 10, loop: 15, pop: 16, process: 17, neighbor: 19, dec: 20, push: 22 },
            java: { init: 3, q_init: 11, loop: 16, pop: 17, process: 18, neighbor: 20, dec: 21, push: 22 },
            python: { init: 3, q_init: 8, loop: 11, pop: 12, process: 13, neighbor: 15, dec: 16, push: 18 }
        };

        // --- Initialization ---
        function init() {
            loadScenario('random');
            renderCode();
            setupDrag();
        }

        function loadScenario(key) {
            reset();
            const data = SCENARIOS[key];
            
            // Deep copy to avoid mutation
            nodes = JSON.parse(JSON.stringify(data.nodes));
            edges = JSON.parse(JSON.stringify(data.edges));
            
            // Layout nodes (Simple Force Layout)
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(edges).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .stop();

            // Run simulation for static layout
            for (let i = 0; i < 300; ++i) simulation.tick();
            
            drawGraph();
            generateSteps();
        }

        function drawGraph() {
            svg.selectAll("*").remove(); // Clear
            
            // Defs (Arrows)
            const defs = svg.append("defs");
            defs.append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 25) // Offset for node radius
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#94a3b8");

            defs.append("marker")
                .attr("id", "arrow-active")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 25)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#38bdf8");

            // Edges
            const link = svg.append("g")
                .selectAll("line")
                .data(edges)
                .enter().append("line")
                .attr("class", "edge")
                .attr("id", d => `edge-${d.source.id}-${d.target.id}`)
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            // Nodes
            const node = svg.append("g")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("id", d => `node-${d.id}`)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.append("circle")
                .attr("r", 20);

            node.append("text")
                .text(d => d.label)
                .attr("dy", 4);

            // In-Degree Badge
            const badge = node.append("g")
                .attr("class", "badge-group")
                .attr("transform", "translate(15, -15)");
            
            badge.append("circle")
                .attr("r", 8)
                .attr("class", "badge-bg")
                .attr("id", d => `badge-bg-${d.id}`);
            
            badge.append("text")
                .attr("class", "badge")
                .attr("id", d => `badge-val-${d.id}`)
                .attr("dy", 3)
                .text("0");
        }

        // --- Algorithm Logic ---
        function generateSteps() {
            steps = [];
            
            // 1. Calculate In-Degrees
            const inDegree = {};
            const adj = {};
            nodes.forEach(n => {
                inDegree[n.id] = 0;
                adj[n.id] = [];
            });
            
            edges.forEach(e => {
                // D3 converts source/target to objects, access ID
                const u = e.source.id;
                const v = e.target.id;
                adj[u].push(v);
                inDegree[v]++;
            });

            // Initial State
            steps.push({
                type: 'init',
                inDegree: {...inDegree},
                queue: [],
                result: [],
                msg: "Initialized in-degrees.",
                line: 'init'
            });

            // 2. Init Queue
            const queue = [];
            nodes.forEach(n => {
                if (inDegree[n.id] === 0) queue.push(n.id);
            });
            
            steps.push({
                type: 'queue_init',
                inDegree: {...inDegree},
                queue: [...queue],
                result: [],
                msg: `Nodes with 0 in-degree added to queue: ${queue.join(', ')}`,
                line: 'q_init'
            });

            const result = [];
            
            // 3. Process
            while (queue.length > 0) {
                // Snapshot before pop
                steps.push({
                    type: 'loop_start',
                    inDegree: {...inDegree},
                    queue: [...queue],
                    result: [...result],
                    msg: "Queue is not empty, processing next node.",
                    line: 'loop'
                });

                const u = queue.shift();
                result.push(u);

                steps.push({
                    type: 'process',
                    inDegree: {...inDegree},
                    queue: [...queue],
                    result: [...result],
                    activeNode: u,
                    msg: `Processed ${u}. Added to topological order.`,
                    line: 'process'
                });

                // Neighbors
                const neighbors = adj[u] || [];
                for (const v of neighbors) {
                    inDegree[v]--;
                    
                    steps.push({
                        type: 'neighbor',
                        inDegree: {...inDegree},
                        queue: [...queue],
                        result: [...result],
                        activeNode: u,
                        activeEdge: {u, v},
                        msg: `Removing edge ${u} -> ${v}. ${v} in-degree becomes ${inDegree[v]}.`,
                        line: 'dec'
                    });

                    if (inDegree[v] === 0) {
                        queue.push(v);
                        steps.push({
                            type: 'push',
                            inDegree: {...inDegree},
                            queue: [...queue],
                            result: [...result],
                            activeNode: u,
                            activeEdge: {u, v},
                            msg: `${v} has 0 in-degree! Added to queue.`,
                            line: 'push'
                        });
                    }
                }
            }

            // Cycle Check
            if (result.length !== nodes.length) {
                steps.push({
                    type: 'cycle',
                    inDegree: {...inDegree},
                    queue: [],
                    result: [...result],
                    msg: "Cycle Detected! Queue empty but nodes remain.",
                    isError: true
                });
            } else {
                steps.push({
                    type: 'done',
                    inDegree: {...inDegree},
                    queue: [],
                    result: [...result],
                    msg: "Topological Sort Complete!",
                    isDone: true
                });
            }
            
            // Update total steps
            document.getElementById('step-counter').innerText = `Step 0/${steps.length - 1}`;
        }

        // --- Visualization Engine ---
        function updateView(stepIdx) {
            const s = steps[stepIdx];
            if (!s) return;

            // 1. Update Text
            document.getElementById('step-counter').innerText = `Step ${stepIdx}/${steps.length - 1}`;
            document.getElementById('explanation').innerText = s.msg;
            
            // 2. Update Queue Viz
            const qContainer = document.getElementById('queue-viz');
            qContainer.innerHTML = '';
            if (s.queue.length === 0) {
                qContainer.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.8rem;">Empty</span>';
            } else {
                s.queue.forEach(id => {
                    const el = document.createElement('div');
                    el.className = 'node-card';
                    el.innerText = getNodeLabel(id);
                    qContainer.appendChild(el);
                });
            }

            // 3. Update Result Viz
            const rContainer = document.getElementById('result-viz');
            rContainer.innerHTML = '';
            if (s.result.length === 0) {
                rContainer.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.8rem;">Empty</span>';
            } else {
                s.result.forEach(id => {
                    const el = document.createElement('div');
                    el.className = 'result-node';
                    el.innerText = getNodeLabel(id);
                    rContainer.appendChild(el);
                });
            }

            // 4. Update Graph Styles
            // Reset
            d3.selectAll('.node').classed('active', false).classed('processed', false).classed('queue', false);
            d3.selectAll('.edge').classed('active', false).classed('faded', false);
            d3.select('#cycle-warning').style('display', 'none');

            // Apply State
            // Processed nodes
            s.result.forEach(id => d3.select(`#node-${id}`).classed('processed', true));
            // Queue nodes
            s.queue.forEach(id => d3.select(`#node-${id}`).classed('queue', true));
            // Active Node
            if (s.activeNode) {
                d3.select(`#node-${s.activeNode}`).classed('active', true);
            }
            // Active Edge
            if (s.activeEdge) {
                d3.select(`#edge-${s.activeEdge.u}-${s.activeEdge.v}`).classed('active', true);
            }
            // Faded edges (processed)
            edges.forEach(e => {
                if (s.result.includes(e.source.id)) {
                    d3.select(`#edge-${e.source.id}-${e.target.id}`).classed('faded', true);
                }
            });

            // 5. Update Badges
            nodes.forEach(n => {
                const val = s.inDegree[n.id];
                d3.select(`#badge-val-${n.id}`).text(val);
                d3.select(`#badge-bg-${n.id}`).classed('zero', val === 0);
            });

            // 6. Code Highlight
            if (s.line) highlightLine(s.line);

            // 7. Cycle Warning
            if (s.isError) {
                d3.select('#cycle-warning').style('display', 'block');
            }
        }

        function getNodeLabel(id) {
            const n = nodes.find(x => x.id === id);
            return n ? n.label : id;
        }

        // --- Controls ---
        function stepForward() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                updateView(currentStep);
            } else {
                isPlaying = false;
                document.getElementById('play-btn').innerHTML = '<i class="fas fa-play"></i> Play';
            }
        }

        function stepBackward() {
            if (currentStep > 0) {
                currentStep--;
                updateView(currentStep);
            }
        }

        function togglePlay() {
            const btn = document.getElementById('play-btn');
            if (isPlaying) {
                isPlaying = false;
                clearInterval(timer);
                btn.innerHTML = '<i class="fas fa-play"></i> Play';
            } else {
                if (currentStep >= steps.length - 1) currentStep = 0;
                isPlaying = true;
                btn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                timer = setInterval(() => {
                    if (currentStep < steps.length - 1) {
                        stepForward();
                    } else {
                        togglePlay();
                    }
                }, speed);
            }
        }

        function reset() {
            isPlaying = false;
            clearInterval(timer);
            currentStep = 0;
            document.getElementById('play-btn').innerHTML = '<i class="fas fa-play"></i> Play';
            updateView(0);
        }

        function setSpeed(val) {
            speed = 2100 - val; // Invert so right is faster
            if (isPlaying) {
                clearInterval(timer);
                togglePlay(); togglePlay(); // Restart
            }
        }

        function setMode(m) {
            mode = m;
            // Logic to hide/show elements based on mode
            const exp = document.getElementById('explanation');
            if (mode === 'intermediate') {
                exp.style.filter = 'blur(4px)';
                exp.title = "Hidden in Intermediate Mode";
            } else {
                exp.style.filter = 'none';
            }
            // Expert mode logic would go here (manual clicking)
            if (mode === 'expert') {
                alert("Expert Mode: Click nodes with in-degree 0 to process them manually! (Logic implementation pending)");
            }
        }

        // --- Code Display ---
        function renderCode() {
            const codeBlock = document.getElementById('code-block');
            codeBlock.className = `language-${currentLang}`;
            codeBlock.textContent = CODE_SNIPPETS[currentLang];
            Prism.highlightElement(codeBlock);
        }

        function switchLang(lang) {
            currentLang = lang;
            renderCode();
            // Re-highlight current line
            if (steps[currentStep] && steps[currentStep].line) {
                highlightLine(steps[currentStep].line);
            }
        }

        function highlightLine(key) {
            // Prism.js line highlighting logic
            const lineNum = LINE_MAP[currentLang][key];
            if (!lineNum) return;

            const pre = document.querySelector('pre');
            if (pre) {
                pre.setAttribute('data-line', lineNum);
                Prism.highlightElement(document.getElementById('code-block'));
            }
        }

        // --- Dragging ---
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
            // Update positions manually since simulation is stopped
            d.x = event.x;
            d.y = event.y;
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            
            // Update connected edges
            d3.selectAll(".edge")
                .attr("x1", l => l.source.x)
                .attr("y1", l => l.source.y)
                .attr("x2", l => l.target.x)
                .attr("y2", l => l.target.y);
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function setupDrag() {
            // D3 handles this in drawGraph
        }

        function copyCode() { navigator.clipboard.writeText(CODE_SNIPPETS[currentLang]); }

        // Start
        init();
    </script>
</body>
</html>