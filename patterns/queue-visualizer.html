<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue Visualizer - Software Systems Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <style>
        /* Queue Specific Styles */
        .queue-linear-container {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 5px;
            padding: 30px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 20px;
            min-height: 100px;
            overflow-x: auto;
            position: relative;
            border: 1px solid var(--border-color);
        }

        .queue-item {
            width: 50px;
            height: 50px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--accent-color);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }

        .queue-item.new { animation: slideInRight 0.4s ease; background-color: var(--callout-green); color: black; }
        .queue-item.dequeued { animation: fadeOutLeft 0.4s ease forwards; background-color: var(--callout-red); }
        .queue-item.peek { background-color: var(--callout-yellow); color: black; transform: scale(1.1); }
        
        /* Empty slot style for circular view logic in linear representation */
        .queue-item.empty { 
            border: 1px dashed var(--text-muted); 
            background: transparent; 
            color: var(--text-muted);
            opacity: 0.5;
        }

        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes fadeOutLeft {
            to { opacity: 0; transform: translateX(-20px); }
        }

        .pointer-label {
            position: absolute;
            top: -25px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            width: 100%;
            text-align: center;
        }

        /* Circular Buffer View */
        .circular-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            height: 300px;
            position: relative;
        }

        .circular-cell {
            position: absolute;
            width: 45px;
            height: 45px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-muted);
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .circular-cell.active {
            border-color: var(--accent-color);
            color: var(--text-primary);
            background-color: rgba(59, 130, 246, 0.2);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.2);
        }
        
        .circular-cell.head-cell { border-color: #22c55e; box-shadow: 0 0 15px rgba(34, 197, 94, 0.4); }
        .circular-cell.tail-cell { border-color: #facc15; box-shadow: 0 0 15px rgba(250, 204, 21, 0.4); }

        .center-label {
            position: absolute;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* Code Panel Styles */
        .split-view {
            display: flex;
            gap: 20px;
            height: 100%;
            min-height: 400px;
        }
        .canvas-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        .code-section {
            flex: 1;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 300px;
        }
        .code-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(255,255,255,0.05);
        }
        .algo-code {
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            flex: 1;
        }
        .code-line { padding: 2px 5px; border-radius: 4px; }
        .code-line.active {
            background-color: rgba(250, 204, 21, 0.2);
            border-left: 3px solid #facc15;
            color: #facc15;
        }
        .ln { color: var(--text-muted); margin-right: 10px; user-select: none; }
        .kwd { color: #f472b6; } .com { color: #6b7280; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë Software Systems</h1>
                <p>Queue Visualizer</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Back</div>
                <a href="../lms-dashboard.html" class="nav-item">‚Üê Course Curriculum</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Controls</div>
                <div class="control-group">
                    <label>Value</label>
                    <input type="number" id="val-input" class="control-input" placeholder="Enter number..." value="10">
                    <button class="action-btn" onclick="executeOp('enqueue')">Enqueue</button>
                    <button class="action-btn" onclick="executeOp('dequeue')">Dequeue</button>
                    <button class="action-btn" onclick="executeOp('peek')">Peek</button>
                </div>
                <div class="control-group">
                    <button class="action-btn warning" onclick="resetQueue()">Reset</button>
                </div>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar">
                    <div id="status-text" style="font-family: monospace; color: var(--accent-color);">Ready. Queue is FIFO (First-In, First-Out).</div>
                </div>
                
                <div class="split-view">
                    <!-- Left: Visualization -->
                    <div class="canvas-section" style="overflow-y: auto;">
                        <div style="padding: 20px;">
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Linear View (Logical)</div>
                            <div id="linear-container" class="queue-linear-container">
                                <!-- Items injected here -->
                            </div>

                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Circular Buffer View (Physical Memory)</div>
                            <div id="circular-wrapper" class="circular-wrapper">
                                <div class="center-label">
                                    Capacity: <span id="cap-display">8</span><br>
                                    Size: <span id="size-display">0</span>
                                </div>
                                <!-- Circular cells injected here -->
                            </div>
                        </div>
                    </div>

                    <!-- Right: Code Panel -->
                    <div class="code-section">
                        <div class="code-header">
                            <button class="action-btn" style="padding: 4px 10px; font-size: 0.8rem;" onclick="copyCode()">üìã Copy</button>
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go')">Go</button>
                                <button class="tab-btn" onclick="switchLang('java')">Java</button>
                                <button class="tab-btn" onclick="switchLang('python')">Python</button>
                            </div>
                        </div>
                        <div id="code-display" class="algo-code"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // State
        const CAPACITY = 8;
        let queue = new Array(CAPACITY).fill(null);
        let head = 0;
        let tail = 0;
        let size = 0;
        let currentLang = 'go';
        let currentOp = 'enqueue';

        // DOM Elements
        const linearContainer = document.getElementById('linear-container');
        const circularWrapper = document.getElementById('circular-wrapper');
        const statusText = document.getElementById('status-text');
        const input = document.getElementById('val-input');
        const sizeDisplay = document.getElementById('size-display');

        // Code Definitions
        const CODES = {
            enqueue: {
                go: `func (q *CircularQueue) Enqueue(v int) bool {
    if q.IsFull() { return false }
    q.data[q.tail] = v
    q.tail = (q.tail + 1) % q.capacity
    q.size++
    return true
}`,
                java: `public boolean enqueue(int v) {
    if (isFull()) return false;
    data[tail] = v;
    tail = (tail + 1) % capacity;
    size++;
    return true;
}`,
                python: `def enqueue(self, v):
    if self.is_full(): return False
    self.data[self.tail] = v
    self.tail = (self.tail + 1) % self.capacity
    self.size += 1
    return True`
            },
            dequeue: {
                go: `func (q *CircularQueue) Dequeue() int {
    if q.IsEmpty() { return -1 }
    val := q.data[q.head]
    q.head = (q.head + 1) % q.capacity
    q.size--
    return val
}`,
                java: `public int dequeue() {
    if (isEmpty()) throw new Exception();
    int val = data[head];
    head = (head + 1) % capacity;
    size--;
    return val;
}`,
                python: `def dequeue(self):
    if self.is_empty(): return None
    val = self.data[self.head]
    self.head = (self.head + 1) % self.capacity
    self.size -= 1
    return val`
            },
            peek: {
                go: `func (q *CircularQueue) Front() int {
    if q.IsEmpty() { return -1 }
    return q.data[q.head]
}`,
                java: `public int peek() {
    if (isEmpty()) throw new Exception();
    return data[head];
}`,
                python: `def peek(self):
    if self.is_empty(): return None
    return self.data[self.head]`
            }
        };

        function init() {
            renderCode('enqueue');
            renderCircularStructure();
            renderLinear();
        }

        function renderCircularStructure() {
            // Create cells in a circle
            const radius = 100;
            const centerX = 150; // Half of wrapper width (approx)
            const centerY = 150;
            
            // Clear existing cells but keep label
            const cells = circularWrapper.querySelectorAll('.circular-cell');
            cells.forEach(c => c.remove());

            for (let i = 0; i < CAPACITY; i++) {
                const angle = (i * (360 / CAPACITY)) - 90; // Start at top
                const rad = angle * (Math.PI / 180);
                const x = centerX + radius * Math.cos(rad) - 22.5; // Center offset
                const y = centerY + radius * Math.sin(rad) - 22.5;

                const cell = document.createElement('div');
                cell.className = 'circular-cell';
                cell.id = `circ-cell-${i}`;
                cell.style.left = `${x}px`;
                cell.style.top = `${y}px`;
                cell.innerHTML = `<span style="font-size:0.6rem; position:absolute; top:-15px;">${i}</span>`;
                circularWrapper.appendChild(cell);
            }
        }

        async function executeOp(op) {
            renderCode(op);
            
            if (op === 'enqueue') {
                const val = parseInt(input.value);
                if (isNaN(val)) return;
                
                if (size === CAPACITY) {
                    statusText.textContent = "Queue Overflow! Buffer is full.";
                    highlightLine(2);
                    return;
                }

                highlightLine(1);
                statusText.textContent = `Enqueueing ${val} at tail index ${tail}...`;
                await sleep(500);

                // Update Data
                queue[tail] = val;
                const oldTail = tail;
                tail = (tail + 1) % CAPACITY;
                size++;

                highlightLine(3);
                renderLinear();
                updateCircularView();
                
                // Animate
                const cell = document.getElementById(`circ-cell-${oldTail}`);
                cell.classList.add('active');
                
                highlightLine(4);
                statusText.textContent = `Enqueued ${val}. Tail moved to ${tail}.`;

            } else if (op === 'dequeue') {
                if (size === 0) {
                    statusText.textContent = "Queue Underflow! Queue is empty.";
                    highlightLine(2);
                    return;
                }

                highlightLine(1);
                const val = queue[head];
                statusText.textContent = `Dequeueing ${val} from head index ${head}...`;
                await sleep(500);

                queue[head] = null;
                head = (head + 1) % CAPACITY;
                size--;

                highlightLine(4);
                renderLinear();
                updateCircularView();
                statusText.textContent = `Dequeued ${val}. Head moved to ${head}.`;

            } else if (op === 'peek') {
                if (size === 0) {
                    statusText.textContent = "Queue is empty.";
                    return;
                }
                highlightLine(3);
                const val = queue[head];
                statusText.textContent = `Front element is ${val} at index ${head}`;
                
                // Visual feedback
                const cell = document.getElementById(`circ-cell-${head}`);
                cell.style.transform = "scale(1.2)";
                await sleep(500);
                cell.style.transform = "scale(1)";
            }
            
            sizeDisplay.textContent = size;
        }

        function renderLinear() {
            linearContainer.innerHTML = '';
            // Render logical queue (from head to tail)
            if (size === 0) {
                linearContainer.innerHTML = '<div style="color:var(--text-muted); width:100%; text-align:center;">Empty Queue</div>';
                return;
            }

            for (let i = 0; i < size; i++) {
                const idx = (head + i) % CAPACITY;
                const val = queue[idx];
                
                const item = document.createElement('div');
                item.className = 'queue-item';
                item.textContent = val;
                
                // Add labels for Head/Tail in linear view
                if (i === 0) item.innerHTML += '<div class="pointer-label" style="color:#22c55e; top:-20px;">H</div>';
                if (i === size - 1) item.innerHTML += '<div class="pointer-label" style="color:#facc15; bottom:-20px; top:auto;">T</div>';
                
                linearContainer.appendChild(item);
            }
        }

        function updateCircularView() {
            for (let i = 0; i < CAPACITY; i++) {
                const cell = document.getElementById(`circ-cell-${i}`);
                const val = queue[i];
                
                // Reset classes
                cell.className = 'circular-cell';
                
                // Set content
                // Keep index label
                cell.innerHTML = `<span style="font-size:0.6rem; position:absolute; top:-15px; color:var(--text-muted);">${i}</span>`;
                
                if (val !== null) {
                    cell.classList.add('active');
                    cell.innerHTML += `<span>${val}</span>`;
                }

                // Highlight Head and Tail
                if (size > 0) {
                    if (i === head) cell.classList.add('head-cell');
                    // Tail points to next empty slot, so tail-1 is the last element
                    // But in our logic tail is next empty.
                    // Let's highlight the actual tail pointer (empty slot) or last element?
                    // Usually visualizing pointers is better.
                    if (i === tail) {
                        // Tail pointer (next insert)
                        cell.style.borderStyle = 'dashed';
                        cell.style.borderColor = '#facc15';
                    }
                } else {
                    // Empty
                    if (i === head && i === tail) {
                         cell.style.borderColor = '#fff';
                    }
                }
            }
        }

        function renderCode(op) {
            currentOp = op;
            const code = CODES[op][currentLang];
            const display = document.getElementById('code-display');
            display.innerHTML = '';
            
            const lines = code.split('\n');
            lines.forEach((line, i) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.id = `line-${i+1}`;
                let html = line
                    .replace(/\b(func|var|return|if|else|for|type|struct|public|void|def|class)\b/g, '<span class="kwd">$1</span>')
                    .replace(/\/\/.*/g, '<span class="com">$&</span>');
                div.innerHTML = `<span class="ln">${i+1}</span>${html}`;
                display.appendChild(div);
            });
        }

        function highlightLine(num) {
            document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
            const line = document.getElementById(`line-${num}`);
            if (line) line.classList.add('active');
        }

        function copyCode() {
            const code = CODES[currentOp][currentLang];
            navigator.clipboard.writeText(code);
        }

        function switchLang(lang) {
            currentLang = lang;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            renderCode('enqueue');
        }

        function resetQueue() {
            queue = new Array(CAPACITY).fill(null);
            head = 0;
            tail = 0;
            size = 0;
            renderLinear();
            updateCircularView();
            sizeDisplay.textContent = "0";
            statusText.textContent = "Queue reset.";
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        init();
    </script>
</body>
</html>