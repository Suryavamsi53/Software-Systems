<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree Visualizer - SDE Prep</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="graph-visualizer.css">
    <style>
        .split-view {
            display: flex;
            gap: 20px;
            height: 100%;
            min-height: 500px;
        }

        @media (max-width: 900px) {
            .split-view {
                flex-direction: column;
            }
        }

        .canvas-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            position: relative;
        }

        .code-section {
            flex: 1;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 300px;
        }

        .node-circle {
            fill: var(--bg-tertiary);
            stroke: var(--accent-color);
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .node-circle.active {
            fill: rgba(59, 130, 246, 0.2);
            stroke: #3b82f6;
            stroke-width: 3;
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.6));
        }

        .node-circle.found {
            fill: rgba(16, 185, 129, 0.2);
            stroke: #10b981;
            stroke-width: 3;
            filter: drop-shadow(0 0 8px rgba(16, 185, 129, 0.6));
        }

        .node-circle.deleted {
            fill: rgba(239, 68, 68, 0.2);
            stroke: #ef4444;
            stroke-width: 3;
            filter: drop-shadow(0 0 8px rgba(239, 68, 68, 0.6));
        }

        .node-text {
            fill: var(--text-primary);
            font-weight: bold;
            font-family: 'Inter', monospace;
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .edge-line {
            stroke: var(--text-muted);
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .edge-line.active {
            stroke: #3b82f6;
            stroke-width: 3;
        }

        #tree-svg {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }

        .code-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.05);
        }

        .algo-code {
            padding: 15px;
            overflow-y: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            flex: 1;
        }

        .code-line {
            padding: 2px 5px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .code-line.active {
            background-color: rgba(250, 204, 21, 0.2);
            border-left: 3px solid #facc15;
            color: #facc15;
        }

        .ln {
            color: var(--text-muted);
            margin-right: 10px;
            user-select: none;
        }

        .kwd {
            color: #f472b6;
        }

        .com {
            color: #6b7280;
            font-style: italic;
        }

        .control-input {
            width: 100%;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .play-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-bottom: 5px;
            transition: background 0.2s;
        }

        .play-btn:hover {
            background-color: #2563eb;
        }

        .play-btn.danger {
            background-color: #ef4444;
        }

        .play-btn.danger:hover {
            background-color: #dc2626;
        }

        .play-btn.success {
            background-color: #10b981;
        }

        .play-btn.success:hover {
            background-color: #059669;
        }

        .play-btn.warning {
            background-color: #f59e0b;
        }

        .play-btn.warning:hover {
            background-color: #d97706;
        }
    </style>
</head>

<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>üåë SDE Prep</h1>
                <p>BST Visualizer</p>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Navigation</div>
                <a href="../visualizer-dashboard.html" class="nav-item">‚Üê Dashboard</a>
                <a href="trees.html" class="nav-item">‚Üê Trees Pattern Guide</a>
            </div>
            <div class="nav-section">
                <div class="nav-section-title">Operations</div>
                <div class="control-group">
                    <label>Node Value (0-999)</label>
                    <input type="number" id="node-val" class="control-input" placeholder="e.g. 42" value="42" min="0"
                        max="999">
                    <button class="play-btn success" onclick="startOp('insert')">‚ûï Insert</button>
                    <button class="play-btn" onclick="startOp('search')">üîç Search</button>
                    <button class="play-btn danger" onclick="startOp('delete')">‚ùå Delete</button>
                </div>
                <div class="control-group" style="margin-top: 20px;">
                    <div class="nav-section-title">Settings & Graph</div>
                    <label style="display:block; margin-bottom:5px; font-size:12px; color:var(--text-muted)">Animation
                        Speed</label>
                    <input type="range" id="speed-slider" min="1" max="100" value="50"
                        style="width: 100%; margin-bottom: 15px;">

                    <button class="play-btn warning" onclick="generateRandomTree()">üé≤ Random Tree</button>
                    <button class="play-btn warning"
                        style="background:var(--bg-tertiary); color:var(--text-primary); border:1px solid var(--border-color);"
                        onclick="clearTree()">üóëÔ∏è Clear Tree</button>
                </div>
            </div>
        </aside>

        <main class="main-content no-padding">
            <div class="viz-container">
                <div class="algo-toolbar"
                    style="padding: 15px; border-bottom: 1px solid var(--border-color); background: var(--bg-secondary);">
                    <div id="status-text"
                        style="font-family: 'Fira Code', monospace; font-size: 15px; color: var(--accent-color);">Ready.
                        Insert a node to begin.</div>
                </div>

                <div class="split-view" style="padding: 20px;">
                    <!-- Visualization -->
                    <div class="canvas-section">
                        <svg id="tree-svg"></svg>
                    </div>

                    <!-- Code Panel -->
                    <div class="code-section">
                        <div class="code-header">
                            <span style="font-weight: 600; color: var(--text-primary); font-size: 0.9rem;"
                                id="code-title">Algorithm Logic</span>
                            <div class="btn-group">
                                <button class="tab-btn active" onclick="switchLang('go', this)">Go</button>
                                <button class="tab-btn" onclick="switchLang('java', this)">Java</button>
                                <button class="tab-btn" onclick="switchLang('python', this)">Python</button>
                            </div>
                        </div>
                        <div id="code-display" class="algo-code"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Tree Node Structure
        class TreeNode {
            constructor(val) {
                this.val = val;
                this.left = null;
                this.right = null;
                // Rendering properties
                this.x = 0;
                this.y = 0;
            }
        }

        let root = null;
        let isAnimating = false;
        let currentLang = 'go';
        let currentOp = 'insert';
        let animSpeed = 500; // ms

        // DOM Setup
        const svg = document.getElementById('tree-svg');
        const statusText = document.getElementById('status-text');
        const valInput = document.getElementById('node-val');
        const codeDisplay = document.getElementById('code-display');
        const speedSlider = document.getElementById('speed-slider');

        speedSlider.addEventListener('input', (e) => {
            // Speed mapped from 1000ms (slow) to 100ms (fast)
            animSpeed = 1000 - (e.target.value * 9);
        });

        // Snippets
        const CODES = {
            insert: {
                go: `func insert(root *Node, val int) *Node {
    if root == nil { return &Node{Val: val} }
    if val < root.Val {
        root.Left = insert(root.Left, val)
    } else if val > root.Val {
        root.Right = insert(root.Right, val)
    }
    return root
}`,
                java: `public Node insert(Node root, int val) {
    if (root == null) return new Node(val);
    if (val < root.val) {
        root.left = insert(root.left, val);
    } else if (val > root.val) {
        root.right = insert(root.right, val);
    }
    return root;
}`,
                python: `def insert(root, val):
    if not root: return Node(val)
    if val < root.val:
        root.left = insert(root.left, val)
    elif val > root.val:
        root.right = insert(root.right, val)
    return root`
            },
            search: {
                go: `func search(root *Node, val int) *Node {
    if root == nil || root.Val == val {
        return root
    }
    if val < root.Val {
        return search(root.Left, val)
    }
    return search(root.Right, val)
}`,
                java: `public Node search(Node root, int val) {
    if (root == null || root.val == val) {
        return root;
    }
    if (val < root.val) {
        return search(root.left, val);
    }
    return search(root.right, val);
}`,
                python: `def search(root, val):
    if not root or root.val == val:
        return root
    if val < root.val:
        return search(root.left, val)
    return search(root.right, val)`
            },
            delete: {
                go: `func delete(root *Node, val int) *Node {
    if root == nil { return root }
    if val < root.Val {
        root.Left = delete(root.Left, val)
    } else if val > root.Val {
        root.Right = delete(root.Right, val)
    } else {
        if root.Left == nil { return root.Right }
        if root.Right == nil { return root.Left }
        min := minValue(root.Right)
        root.Val = min
        root.Right = delete(root.Right, min)
    }
    return root
}`,
                java: `public Node delete(Node root, int val) {
    if (root == null) return root;
    if (val < root.val) {
        root.left = delete(root.left, val);
    } else if (val > root.val) {
        root.right = delete(root.right, val);
    } else {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        int min = minValue(root.right);
        root.val = min;
        root.right = delete(root.right, min);
    }
    return root;
}`,
                python: `def delete(root, val):
    if not root: return root
    if val < root.val:
        root.left = delete(root.left, val)
    elif val > root.val:
        root.right = delete(root.right, val)
    else:
        if not root.left: return root.right
        if not root.right: return root.left
        min_val = min_value(root.right)
        root.val = min_val
        root.right = delete(root.right, min_val)
    return root`
            }
        };

        // Utility
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        function switchLang(lang, btn) {
            currentLang = lang;
            if (btn) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
            renderCode(currentOp);
        }

        function renderCode(op) {
            currentOp = op;
            document.getElementById('code-title').textContent = op.charAt(0).toUpperCase() + op.slice(1) + " Logic";
            const code = CODES[op][currentLang];
            codeDisplay.innerHTML = '';

            const lines = code.split('\\n');
            lines.forEach((line, i) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.id = \`line-\${i+1}\`;
                let html = line
                    .replace(/\\b(func|return|if|else|def|class|public|int|Node|new|null|nil|None|elif|not)\\b/g, '<span class="kwd">$1</span>')
                    .replace(/\\/\\/.*/g, '<span class="com">$&</span>')
                    .replace(/#.*/g, '<span class="com">$&</span>');
                div.innerHTML = \`<span class="ln">\${i+1}</span>\${html}\`;
                codeDisplay.appendChild(div);
            });
        }

        function highlightLine(num) {
            document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
            const line = document.getElementById(\`line-\${num}\`);
            if (line) {
                line.classList.add('active');
                // Scroll logic
                const container = line.parentElement;
                const offset = line.offsetTop - container.offsetTop - (container.clientHeight / 2);
                container.scrollTo({ top: offset, behavior: 'smooth' });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active'));
        }

        // Tree Math & Layout
        function calculateLayout(node, x, y, level, w) {
            if (!node) return;
            node.x = x;
            node.y = y;
            const delta = w / Math.pow(2, level);
            calculateLayout(node.left, x - delta, y + 60, level + 1, w);
            calculateLayout(node.right, x + delta, y + 60, level + 1, w);
        }

        function getWidth() { return svg.clientWidth || 800; }
        
        function drawTree(activeNode = null, highlightEdgeTo = null, foundMode = false, deleteMode = false) {
            svg.innerHTML = '';
            if (!root) return;

            // Re-calculate layout based on container size
            const width = getWidth();
            calculateLayout(root, width / 2, 40, 1, width / 3);

            // Draw edges first
            drawEdges(root, null, highlightEdgeTo);
            // Draw nodes
            drawNodes(root, activeNode, foundMode, deleteMode);
        }

        function drawEdges(node, parent, highlightEdgeTo) {
            if (!node) return;
            if (parent) {
                const edge = document.createElementNS("http://www.w3.org/2000/svg", "line");
                edge.setAttribute("x1", parent.x);
                edge.setAttribute("y1", parent.y);
                edge.setAttribute("x2", node.x);
                edge.setAttribute("y2", node.y);
                
                if (highlightEdgeTo && highlightEdgeTo.val === node.val) {
                    edge.setAttribute("class", "edge-line active");
                } else {
                    edge.setAttribute("class", "edge-line");
                }
                svg.appendChild(edge);
            }
            drawEdges(node.left, node, highlightEdgeTo);
            drawEdges(node.right, node, highlightEdgeTo);
        }

        function drawNodes(node, activeNode, foundMode, deleteMode) {
            if (!node) return;
            
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", node.x);
            circle.setAttribute("cy", node.y);
            circle.setAttribute("r", 20);
            
            if (activeNode && activeNode.val === node.val) {
                if (deleteMode) circle.setAttribute("class", "node-circle deleted");
                else if (foundMode) circle.setAttribute("class", "node-circle found");
                else circle.setAttribute("class", "node-circle active");
            } else {
                circle.setAttribute("class", "node-circle");
            }

            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", node.x);
            text.setAttribute("y", node.y);
            text.setAttribute("class", "node-text");
            text.textContent = node.val;

            g.appendChild(circle);
            g.appendChild(text);
            svg.appendChild(g);

            drawNodes(node.left, activeNode, foundMode, deleteMode);
            drawNodes(node.right, activeNode, foundMode, deleteMode);
        }

        // Operation Handlers
        async function startOp(op) {
            if (isAnimating) return;
            const val = parseInt(valInput.value);
            if (isNaN(val)) {
                statusText.textContent = "Please enter a valid integer!";
                return;
            }
            isAnimating = true;
            renderCode(op);
            
            if (op === 'insert') {
                statusText.textContent = \`Starting insertion of \${val}...\`;
                root = await insertAnim(root, val, null);
                drawTree();
                statusText.textContent = \`Inserted \${val} successfully.\`;
            } else if (op === 'search') {
                statusText.textContent = \`Searching for \${val}...\`;
                const found = await searchAnim(root, val);
                if (found) {
                    statusText.textContent = \`Found \${val} in the tree!\`;
                    drawTree(found, null, true);
                    await sleep(1500);
                } else {
                    statusText.textContent = \`Value \${val} not found.\`;
                }
                drawTree();
            } else if (op === 'delete') {
                statusText.textContent = \`Searching for \${val} to delete...\`;
                root = await deleteAnim(root, val);
                drawTree();
                statusText.textContent = \`Delete operation finished.\`;
            }
            
            clearHighlights();
            isAnimating = false;
        }

        async function insertAnim(node, val, parent) {
            highlightLine(1);
            await sleep(animSpeed);
            
            highlightLine(2); // if root == nil
            if (!node) {
                await sleep(animSpeed);
                const newNode = new TreeNode(val);
                statusText.textContent = \`Created new node \${val}.\`;
                if (!root) root = newNode; // Ensure layout calculation works if it's the first node
                drawTree(newNode, newNode, true);
                await sleep(animSpeed);
                return newNode;
            }

            drawTree(node, node);
            await sleep(animSpeed);

            highlightLine(3); // if val < root.Val
            if (val < node.val) {
                statusText.textContent = \`\${val} < \${node.val}, going left.\`;
                await sleep(animSpeed);
                highlightLine(4);
                node.left = await insertAnim(node.left, val, node);
            } else if (val > node.val) {
                highlightLine(5); // else if val > root.Val
                statusText.textContent = \`\${val} > \${node.val}, going right.\`;
                await sleep(animSpeed);
                highlightLine(6);
                node.right = await insertAnim(node.right, val, node);
            } else {
                statusText.textContent = \`\${val} already exists! Skipping.\`;
                await sleep(animSpeed);
            }
            
            highlightLine(8); // return root
            drawTree(node);
            await sleep(animSpeed/2);
            return node;
        }

        async function searchAnim(node, val) {
            highlightLine(1);
            await sleep(animSpeed);
            
            drawTree(node, node);
            highlightLine(2); // if root == nil || root.Val == val
            await sleep(animSpeed);
            
            if (!node) {
                highlightLine(3);
                return null;
            }
            if (node.val === val) {
                highlightLine(3);
                return node;
            }

            highlightLine(5); // if val < root.Val
            if (val < node.val) {
                statusText.textContent = \`\${val} < \${node.val}, searching left.\`;
                await sleep(animSpeed);
                highlightLine(6);
                return await searchAnim(node.left, val);
            }
            
            statusText.textContent = \`\${val} > \${node.val}, searching right.\`;
            highlightLine(8); // return search(root.Right, val)
            await sleep(animSpeed);
            return await searchAnim(node.right, val);
        }

        async function deleteAnim(node, val) {
            if (!node) return null;
            
            highlightLine(1);
            await sleep(animSpeed/2);
            
            drawTree(node, node);
            highlightLine(2); 
            await sleep(animSpeed/2);
            
            highlightLine(3); // if val < root.Val
            if (val < node.val) {
                statusText.textContent = \`\${val} < \${node.val}, going left.\`;
                await sleep(animSpeed);
                highlightLine(4);
                node.left = await deleteAnim(node.left, val);
            } else if (val > node.val) {
                highlightLine(5);
                statusText.textContent = \`\${val} > \${node.val}, going right.\`;
                await sleep(animSpeed);
                highlightLine(6);
                node.right = await deleteAnim(node.right, val);
            } else {
                // Found the node
                statusText.textContent = \`Found \${node.val} to delete.\`;
                drawTree(node, null, false, true); // delete mode
                await sleep(animSpeed);
                
                highlightLine(9); // if root.Left == nil
                if (!node.left) {
                    statusText.textContent = \`No left child, replacing with right child.\`;
                    await sleep(animSpeed);
                    return node.right;
                }
                
                highlightLine(10); // if root.Right == nil
                if (!node.right) {
                    statusText.textContent = \`No right child, replacing with left child.\`;
                    await sleep(animSpeed);
                    return node.left;
                }
                
                statusText.textContent = \`Node has two children. Finding minimum in right subtree.\`;
                highlightLine(11); // min := minValue(root.Right)
                await sleep(animSpeed);
                
                let minNode = node.right;
                while (minNode.left) minNode = minNode.left;
                
                drawTree(minNode, null, true); // found mode
                statusText.textContent = \`Minimum in right subtree is \${minNode.val}.\`;
                await sleep(animSpeed * 1.5);
                
                highlightLine(12); // root.Val = min
                node.val = minNode.val;
                drawTree(node, null, true);
                statusText.textContent = \`Replaced value with \${minNode.val}.\`;
                await sleep(animSpeed);
                
                highlightLine(13); // root.Right = delete(root.Right, min)
                statusText.textContent = \`Recursively deleting the old min node \${minNode.val}.\`;
                await sleep(animSpeed);
                node.right = await deleteAnim(node.right, minNode.val);
            }
            
            highlightLine(15);
            return node;
        }

        // Setup
        function clearTree() {
            if (isAnimating) return;
            root = null;
            drawTree();
            statusText.textContent = "Tree cleared.";
            clearHighlights();
        }

        async function generateRandomTree() {
            if (isAnimating) return;
            clearTree();
            const count = 10;
            const vals = new Set();
            while(vals.size < count) vals.add(Math.floor(Math.random() * 100));
            
            const arr = Array.from(vals);
            // Quick silent insert
            for(let v of arr) {
                root = insertNodeSilent(root, v);
            }
            drawTree();
            statusText.textContent = "Generated random BST.";
            renderCode('insert');
        }

        function insertNodeSilent(node, val) {
            if (!node) return new TreeNode(val);
            if (val < node.val) node.left = insertNodeSilent(node.left, val);
            else if (val > node.val) node.right = insertNodeSilent(node.right, val);
            return node;
        }

        // Initialize empty layout
        window.addEventListener('resize', () => { if(!isAnimating) drawTree(); });
        renderCode('insert');
        drawTree();
        
        // Initial tree
        root = insertNodeSilent(null, 50);
        insertNodeSilent(root, 30);
        insertNodeSilent(root, 70);
        insertNodeSilent(root, 20);
        insertNodeSilent(root, 40);
        insertNodeSilent(root, 60);
        insertNodeSilent(root, 80);
        drawTree();
    </script>
</body>

</html>